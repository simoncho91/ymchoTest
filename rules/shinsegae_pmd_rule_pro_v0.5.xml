<?xml version="1.0" encoding="UTF-8"?>
<ruleset xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         name="SHINSEGAE InC PMD Standard Ruleset"
         xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">
    <description>신세계아이앤씨 PMD 표준 Rule Set</description>
    <!-- 변경 이력 -->
    <!-- 0.1버전 :  전자정부 기반으로 초기 46개 rule -->
    <!-- 0.2버전 :  성능, basic, design rule 등을 추가하여 rule 139개로 늘림 -->
    <!-- 0.3버전 :
        # 시스템개발팀과 품질관리팀에서 확인한 Rule 131개로 확정
        # Rule의 Message와 Example 재정의
    -->
    <!-- 0.4버전 :
        # 0.3버전에서 제외되었던 보안 취약점과 관련된 AvoidReassigningParameters, ArrayIsStoredDirectly Rule 추가
        
    -->
	<!-- 0.5버전 :
	1) 보안 취약점과 관련된 PMD rule우선순위 조정
	     AvoidPrintStackTrace(3) ->(1), EmptyCatchBlock(3) -> (1) , AvoidCatchingNPE(3)->(1), BrokenNullCheck(2) ->(1),MisplacedNullCheck(3) -> (1)
		 CloseResource(3) ->(1),ArrayIsStoredDirectly(3) ->(2),MethodReturnsInternalArray(3) ->(2)
	2) property변경 사항
         - AvoidDeeplyNestedIfStmts : 중첩도 3 -> 4로 변경
         - CyclomaticComplexity (java) : 복잡도 10 -> 15로 변경
         - LongVariable : 24 제한 변경 없음, 단 static final 변수는 제외
         - VariableNamingConventions : static final 변수명 체크에서 logger는 제외	 
	3) RuleSet삭제
         - AvoidInstantiatingObjectsInLoops (반복문 내부에서 생성되는 객체) 삭제	
	-->	 
		 

    <!-- 체크 제외 소스 -->
    <exclude-pattern>.*/src/test/.*</exclude-pattern>
    <exclude-pattern>.*/target/.*</exclude-pattern>

    <!-- 기존 룰셋 -->
    <!-- 1.전자정부 0.1 기준 rule -->
    <rule message="부정확한 null 조건 비교" ref="rulesets/java/basic.xml/BrokenNullCheck">
        <description>
부정확한 null 조건 비교는 NullPointerException을 일으킬 수 있다.
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
public String bar(String string) {
    // null 여부는 체크하지만 ""와 같은지는 체크하지 않음
    if (string != null || !string.equals(""))
        return string;

    // String이 null일 경우 equals()를 사용하면서 NPE 발생
    if (string == null && string.equals(""))
        return string;
		
/* 참고 : short circuit
조건식 1 && 조건식 2 : 조건식 1 이 false 이면, 조건식 2 를 건너뜀
조건식 1 || 조건식 2 : 조건식 1 이 true 이면, 조건식 2 를 건너뜀 */
}

//좋은 예
// #1 - 조건을 정확히 사용
public String bar(String string) {
    if (string != null && !string.equals(""))
        return string;

    if (string == null || string.equals(""))
        return string;
}

// #2 - StringUtils.isEmpty 또는 StringUtils.isBlank 이용
import org.apache.commons.lang3.StringUtils;

public String bar(String string) {
    if (!StringUtils.isEmpty(string))
        return string;

    if (!StringUtils.isBlank(string))
        return string;
}
     ]]></example>
    </rule>
    <rule message="잘못된 위치의 null 조건 비교" ref="rulesets/java/basic.xml/MisplacedNullCheck">
        <description>
부적절한 위치에서 null 조건을 비교하여 NullPointerException을 일으킬 수 있다.
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
  vold bar() {
    if (a.equals(baz) && a != null) {} // NPE 발생
  }
}

public class Foo {
  vold bar() {
    if (a.equals(baz) || a == null) {} // NPE 발생
  }
}

//좋은 예
public class Foo {
  vold bar() {
    // null 체크 우선
    if (a != null && a.equals(baz)) {}
  }
}

public class Foo {
  vold bar() {
    // null 체크 우선
    if (a == null || a.equals(baz)) {}
  }
}
     ]]></example>
    </rule>
    <rule message="equals()로 null 비교" ref="rulesets/java/design.xml/EqualsNull">
        <description>
equals 메소드로 null을 비교하지 않는다.
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
class Bar {
  void foo() {
    String x = "foo";
    if (x.equals(null)) { // 잘못된 비교
      doSomething();
    }
  }
}

//좋은 예
class Bar {
  void foo() {
    String x = "foo";
    if (x != null && x.equals("")) {
      doSomething();
    }
  }
}
     ]]></example>
    </rule>
    <rule message="System.out.println() 사용" ref="rulesets/java/logging-java.xml/SystemPrintln">
        <description>
로그 출력 목적으로 system.out.println을 사용하지 말고 로거를 사용한다. (log4j2 등)
System.out.println() 을 사용하면 로그 레벨을 조정한다거나, 로그를 켜고 끄는 등의 로그 정책을 세울 수 없다.
        </description>
        <priority>2</priority>
        <example><![CDATA[
//나쁜 예
class Foo {
  public void testA() {
    System.out.println("Entering test");
  }
}

//좋은 예
class Foo {
  private static final Logger LOGGER = LoggerFactory.getLogger(this.class);
  public void testA() {
    LOGGER.info("Entering test");
  }
}
     ]]></example>
    </rule>
    <rule message="printStackTrace() 사용" ref="rulesets/java/logging-java.xml/AvoidPrintStackTrace">
        <description>
printStackTrace() 메소드를 사용하여 로그 메시지를 출력하지 않는다. 대신 별도의 로거를 사용하여 메시지를 확인하도록 한다.
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
class Foo {
  void bar() {
    try {
      // do something
    } catch (Exception e) {
        e.printStackTrace(); // printStackTrace 사용 금지
    }
  }
}

//좋은 예
class Foo {
  // 로거 선언. 선언 방법은 프로젝트 표준에 따라 다들 수 있음.
  private static final Logger LOGGER = LoggerFactory.getLogger(this.class);
  void bar() {
    try {
      // do something
    } catch (Exception e) {
        LOGGER.error(e.getMessage(), e);  // 로거 사용
    }
  }
}
     ]]></example>
    </rule>
    <rule message="while문 사용 시 중괄호 미사용" ref="rulesets/java/braces.xml/WhileLoopsMustUseBraces">
        <description>
for, while 반복문에서 코드가 단 한 줄만 있을 경우라도 소스코드의 구역을 제대로 구분할 수 있도록 괄호{ } 를 반드시 사용한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
for(int i=0; i < 10; i++)
    size++;

while(size<20)
    size++;

//좋은 예
for(int i=0; I < 10; i++) {
    size++;
}

while(size<20) {
    size++;
}
     ]]></example>
    </rule>
    <rule message="Private 배열에 대한 임의 접근" ref="rulesets/java/sunsecure.xml/MethodReturnsInternalArray">
        <description>
클래스 내부의 배열을 직접적으로 반환하면 사용자는 외부에서 임의로 내부 배열을 수정할 수 있다. 이는 매우 치명적인 오류를 발생시킬 수 있는 원인이 된다. 보다 안전한 방법으로 내부의 배열을 복사하여 전달하도록 한다.
        </description>
        <priority>2</priority>
        <example><![CDATA[
//나쁜 예
public class SecureSystem {
  UserData [] ud;
  public UserData [] getUserData() {
    return ud;
  }
}

//좋은 예
public class SecureSystem {
  UserData [] ud;
  public UserData [] getUserData() {
    // 내부 배열을 로컬 임시 배열로 복사 후 사용
    UserData [] arrRtrnUsrData = Arrays.copyOf(ud, ud.length);
    return arrRtrnUsrData;
  }
}
     ]]></example>
    </rule>
    <rule message="전달받은 배열의 직접적인 사용" ref="rulesets/java/sunsecure.xml/ArrayIsStoredDirectly">
        <description>
생성자와 메소드는 전달받은 배열은 복제 객체를 만들거나 배열의 복사본을 만들어서 사용한다. 이는 외부 사용자가 임의로 내부의 기능(functionality)을 변경하는 것을 막는다.
        </description>
        <priority>2</priority>
        <example><![CDATA[
//나쁜 예
public void setMessageParameters(Object[] messageParameters) {
     this.messageParameters = messageParameters;
}

//좋은 예
public void setMessageParameters(Object[] messageParameters) {
        // 배열 복사하여 저장 (PMD)
        if (messageParameters == null) {
            this.messageParameters = null;
        } else {
            this.messageParameters = new Object[messageParameters.length];
            System.arraycopy(messageParameters, 0, this.messageParameters, 0,messageParameters.length);
        }
}
     ]]></example>
    </rule>
    <rule message="자원 해제 미실시" ref="rulesets/java/design.xml/CloseResource">
        <description>
자원을 사용하고 반환하지 않는 것은 다른 프로세스나 스레드가 자원을 사용할 수 없게 하고 메모리 누수(memory leak)를 일으키는 주요 원인이다. finally 절에 자원 종료 코드를 삽입하여 자원이 해제되도록 조치한다.
 ※ spring 프레임워크에서 AOP로 구성하는 경우는 프레임워크 자체에서 자원 반환을 해주기 때문에 finally 절에서 반환할 필요가 없으나, 직접적으로 connection을 맺어 사용하는 경우 반드시 반환 처리한다.
 ※  자원 : ResultSet, Statement, PreparedStatement, Connection, Socket, FileStream 등
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
// 리소스 사용 후 close 하지 않음
public class Bar {
  public void foo() {
    Connection conn = pool.getConnection();
    try {
        // 프로세스 구현
    } catch (SQLException ex) {
        // 에러처리부분
    }
    // 리소스 반환 로직 없음
  }
}

//좋은 예
public class Bar {
  public void foo() {
    Connection conn = pool.getConnection();
    try {
        // 프로세스 구현
    } catch (SQLException ex) {
        // 에러처리부분
    } finally {
        // close()를 잊지 말것
        conn.close();
    }
  }
}
     ]]></example>
    </rule>
    <rule message="전달받은 파라미터의 직접적인 변경" ref="rulesets/java/design.xml/AvoidReassigningParameters">
        <description>
파라미터로 전달된 변수는 임시 지역 변수로 전달 받아 사용해야 한다. Object 타입은 필수로 적용해야 하지만, 합당한 사유가 있을 경우 사유로 대체한다.
 * JAVA에서 매개변수를 전달할 경우, primitive 타입은 변수 값의 복사본을 전달하지만 Object 타입은 복사본이 아닌 참조값(메모리의 주소)를 넘긴다.
        </description>
        <priority>2</priority>
        <example><![CDATA[
//나쁜 예
public static HashMap fileCopy(byte[] file, String sFilePath) {
    if (sFilePath == null || "".equals(inFilePath)) {
        // 파라미터를 직접 변경하고 있음
        sFilePath = “C:/FILE/PATH/”;
    }
}

//좋은 예
public static HashMap fileCopy(byte[] file, String sFilePath) {
    // 새로운 변수를 생성하여 사용
    String inFilePath = sFilePath;
    if (inFilePath == null || "".equals(inFilePath)) {
        inFilePath = “C:/FILE/PATH/”;
    }
}
     ]]></example>
    </rule>
    <rule message="static 필드의 안전하지 않은 사용" ref="rulesets/java/design.xml/AssignmentToNonFinalStatic">
        <description>
static 필드의 안전하지 않은 사용 가능성이 있다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class StaticField {
  static int x;
  public FinalFields(int y) {
    x = y;
  }
}

//좋은 예
public class StaticField {
  static int x;
  public FinalFields(int y) {
    // x값을 변경하지 않도록 로직 변경 (변경이 필요하다면 새로운 변수에 카피하여 사용)
    // x값 변경이 없다면 static final로 상수화하여 사용하는 것도 고려한다.
    ...
  }
}
     ]]></example>
    </rule>
    <rule message="Interface의 잘못된 사용" ref="rulesets/java/design.xml/AvoidConstantsInterface">
        <description>
인터페이스를 추상클래스와 혼동하여 객체의 구현과 밀접하게 연관된 필드를 정의할 경우, 데이터 은닉을 위한 캡슐화를 위배하게 된다.
 - 인터페이스 : 클래스의 behavior를 정의하는 기능 명세서 역할. 인터페이스를 구현한 객체들에 대한 동일한 동작을 보장.
 - 추상클래스 : 추상 클래스를 상속받아서 기능을 이용하고, 확장시키는 데 목적이 있음.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
//상수(static final) 자료형이 인터체이스에 포함되어 있음.
public interface ConstantsInterface {
    public static final int CONSTANT1 = 0;
    public static final String CONSTANT2 = "1";
    void method1();
    int method2();
}

//좋은 예
//메소드만 포함
public interface ConstantsInterface {
  void method1();
  int method2();
}
     ]]></example>
    </rule>
    <rule message="Method 레벨 동기화 사용" ref="rulesets/java/design.xml/AvoidSynchronizedAtMethodLevel">
        <description>
메소드 단위의 동기화보다는 블록 단위의 동기화를 사용하여 필요한 부분만 동기화하도록 한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
  syncronized void foo() {
  }

  static syncronized void fooStatic() {
  }
}

//좋은 예
public class Foo {
    void bar() {
        synchronized(this) {
        }
    }

    static void barStatic() {
        synchronized(Foo.class) {
        }
    }
}
     ]]></example>
    </rule>
    <rule message="final field는 static final로 변경" ref="rulesets/java/design.xml/FinalFieldCouldBeStatic">
        <description>
final로 설정된 필드는 컴파일 시에 자동으로 static으로 전환된다. Overhead를 줄이기 위해 final 필드는 static도 같이 설정하는 것이 좋다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    public final int BAR = 42;
}

//좋은 예
public class Foo {
    public static final int BAR = 42;
}
     ]]></example>
    </rule>
    <rule message="변경되지 않는 private field는 final로 변경" ref="rulesets/java/design.xml/ImmutableField">
        <description>
private field가 직접적인 선언 / 생성자로부터 초기화된 이후로 변경되지 않는다면 final로 선언하여 상수로 등록하는 것을 권장한다. 이것은 클래스를 불변(immutable) 클래스로 전환하는데도 도움이 된다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    private int x;
    public Foo() {
        x = 7;
    }
    public void foo() {
        int a = x + 2;
    }
}

//좋은 예
public class Foo {
    private final int x;
    public Foo() {
        x = 7;
    }
    public void foo() {
        int a = x + 2;
    }
}
     ]]></example>
    </rule>
    <rule message="SimpleDateFormat에서 Locale 미설정" ref="rulesets/java/design.xml/SimpleDateFormatNeedsLocale">
        <description>
SimpleDateFormat의 인스턴스를 생성할 때는 Locale을 명시하여 생성한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
// 누락된 Locale 정보
public class Foo {
    private SimpleDataFormat sdf = new SimpleDataFormat("yyyyMMdd");
}

//좋은 예
public class Foo {
    private SimpleDataFormat sdf = new SimpleDataFormat("yyyyMMdd", Locale.KOREAN);
}
     ]]></example>
    </rule>
    <rule message="불필요한 boolean 비교" ref="rulesets/java/design.xml/SimplifyBooleanExpressions">
        <description>
boolean 사용 시 불필요한 비교 연산을 하지 않는다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Bar {
    private boolean bar = (isFoo() == true);
    public isFoo() {return false;}
}

//좋은 예
public class Bar {
  private boolean bar = isFoo();
  public isFoo() {return false;}
}
     ]]></example>
    </rule>
    <rule message="Switch 구문에서 default label 미사용" ref="rulesets/java/design.xml/SwitchStmtsShouldHaveDefault">
        <description>
switch 문의 default 절은 if 문의 else 와 같은 역할을 한다. default 절을 사용하지 않으면 정해진 case 외의 예외적인 조건은 처리 할 수 없다. 따라서 예상치 못한 경우의 수 발생시 치명적인 소프트웨어 결함으로 이어질 수 있기 때문에 반드시 default 절을 사용한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    int x = 2;
    switch (x) {
    case 1: int j = 6;
    case 2: int j = 8;
    // default절 누락
    }
}

//좋은 예
public void bar() {
    int x = 2;
    switch (x) {
    case 1: int j = 6;
    case 2: int j = 8;
    default: int j = 10;
    }
}
     ]]></example>
    </rule>
    <rule message="NullPointerException 단순 catch 처리" ref="rulesets/java/strictexception.xml/AvoidCatchingNPE">
        <description>
일반적인 환경에서 절대 NPE (NullPointerException)을 단순히 catch절로 잡아서 처리하지 않는다. 대부분의 NPE가 발생할 때 NPE는 표면적인 이유이고 근본적인 오류의 원인은 숨어있는 경우가 많다.
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    void bar() {
        try {
            // ...
        } catch (NullPointerException npe) {
        }
    }
}

//좋은 예
public class Foo {
    void bar() {
        try {
            // ...
        } catch (ArithmeticException ae) {
        }
    }
}
     ]]></example>
    </rule>
    <rule message="NullPointerException throw" ref="rulesets/java/strictexception.xml/AvoidThrowingNullPointerException">
        <description>
NullPointerException을 throw하지 않는다. 대신 IllegalArgumentException 사용할 수 있는지 확인한다.
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    void bar() {
        throw new NullPointerException();
    }
}

//좋은 예
public class Foo {
    void bar() {
        throw new IllegalArgumentException();
    }
}
     ]]></example>
    </rule>
    <rule message="명확하지 않은 Exception throw" ref="rulesets/java/strictexception.xml/AvoidThrowingRawExceptionTypes">
        <description>
단순히 RuntimeException, Throwable, Exception, Error를 전달하지 말고 더욱 명확한 오류 타입들로 전달한다.
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    public void bar() throws Exception {
        throw new Exception();
    }
}

//좋은 예
public class Foo {
    public void bar() throws ArithmeticException {
        throw new ArithmeticException();

        // 또는 별도로 정의된 Exception 을 사용
        throw new CustomException();
    }
}
     ]]></example>
    </rule>
    <rule message="부적절한 prefix 사용 (m_)" ref="rulesets/java/naming.xml/MisleadingVariableName">
        <description>
field(멤버 변수)가 아닌 로컬 변수 / 파라미터 명이 m_ 으로 시작되지 않도록 한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    private int m_foo;
    public void bar(String m_baz) {
        int m_boz = 42;
    }
}

//좋은 예
public class Foo {
    // 멤버변수만 prefix 'm_'
    private int m_foo;
    public void bar(String baz) {
        int boz = 42;
    }
}
     ]]></example>
    </rule>
    <rule message="불필요한 String Instance 생성" ref="rulesets/java/strings.xml/StringInstantiation">
        <description>
불필요한 형변환 또는 형변환을 위한 메서드 사용은 중복 인스턴스를 생성함으로써 메모리 자원이 낭비되고 성능 저하를 일으킨다.
        </description>
        <priority>2</priority>
        <example><![CDATA[
//나쁜 예
private String bar = new String("bar");

//좋은 예
private String bar = "bar";
     ]]></example>
    </rule>
    <rule message="String.trim().length() 사용" ref="rulesets/java/strings.xml/InefficientEmptyStringCheck">
        <description>
빈 문자열인지 확인하기 위해  String.trim().length()을 사용하지 않는다. 이 방식은 문자열의 길이를 확인하기 위해 새로운 String 객체를 생성한다.
 1. static 메소드와 반복문을 사용하여 문자열 전체를 character 단위로 Caracter.isWhitespace()를 확인하고 공백 문자가 아닌 문자가 있다면 false를 반환한다.
 2. StringUtils.isEmpty 또는 StringUtils.isBlank 이용
      (org.apache.commons.lang.StringUtils, org.apache.commons.lang3.StringUtils)
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar(String string) {
    if (string != null && string.trim().size() > 0) {
        doSomething();
    }
}

//좋은 예
// Character.isWhitespace()를 사용한 static function
public static boolean isBlank(final String str) {
    int strLen;
    boolean result = true;
    if (str == null || str.length() == 0) {
        result = true;
    } else {
        strLen = str.length();
        for (int i = 0; i < strLen; i++) {
            if (Character.isWhitespace(str.charAt(i))) {
                result = false;
                break;
            }
        }
    }
    return result;
}
     ]]></example>
    </rule>
    <rule message="StringBuffer의 잘못된 사용" ref="rulesets/java/strings.xml/InefficientStringBuffering">
        <description>
StringBuffer 또는 StringBuilder를 사용하는 주된 목적은 + 연산자를 사용하지 않고 효율적인 문자열을 처리하는 데 있다. 하지만 생성자와 append 메서드의 파라미터에 + 연산자를 사용하게 되면 불필요한 인스턴스가 생성되고 실행 속도가 저하된다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    // 불필요한 인스턴스 생성됨
    StringBuffer sb = new StringBuffer("tmp =" + System.getProperty("java.io.tmpdir"));
}

//좋은 예
public void bar() {
    StringBuffer sb = new StringBuffer("tmp =");
    sb.append(System.getProperty("java.io.tmpdir"));
}
     ]]></example>
    </rule>
    <rule message="불필요한 toString() 사용" ref="rulesets/java/strings.xml/StringToString">
        <description>
String 객체에서 toString()함수를 사용하는 것은 불필요하다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
private String baz() {
    String bar = "howdy";
    return bar.toString();
}

//좋은 예
private String baz() {
    String bar = "howdy";
    return bar;
}
     ]]></example>
    </rule>
    <rule message="불필요한 String.valueOf() 사용" ref="rulesets/java/strings.xml/UselessStringValueOf">
        <description>
String을 append할 경우, String.valueOf() 메소드를 사용할 필요 없다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public String convert(int i) {
    String s;
    s = "a" + String.valueOf(i);
    return s;
}

//좋은 예
public String convert(int i) {
    String s;
    s = "a" + i;
    return s;
}
     ]]></example>
    </rule>
    <rule message="피연산자 내에 할당문 사용" ref="rulesets/java/controversial.xml/AssignmentInOperand">
        <description>
피연산자 내에 사용된 할당문은 코드를 복잡하게 하고 가독성을 떨어지게 만든다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    int x = 2;
    if ((x = getX()) == 3) { // 비교 연산 내에서 대입 하지 않는다
        System.out.println("3!");
    }
}

//좋은 예
public void bar() {
    int x = 2;
    x = getX();
    if ((x == 3) {
        System.out.println("3!");
    }
}
     ]]></example>
    </rule>
    <rule message="불필요한 괄호 사용" ref="rulesets/java/controversial.xml/UnnecessaryParentheses">
        <description>
괄호가 없어도 되는 상황에서 불필요하게 괄호를 사용할 경우, 마치 메소드 호출처럼 보여 소스 코드의 가독성을 떨어뜨릴 수 있다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    boolean bar() {
        return (true);
    }
}

//좋은 예
public class Foo {
    boolean bar() {
        return true;
    }
}
     ]]></example>
    </rule>
    <rule message="루프문을 이용한 배열 복사" ref="rulesets/java/optimizations.xml/AvoidArrayLoops">
        <description>
배열 간 데이터를 복사할 경우, for문을 사용하여 복사하는 것보다 System.arraycopy 나 Arrays.copyOf 메소드를 사용하는 것이 더 효율적이다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Test {
  public void bar() {
      int[] a = new int[10];
      int[] b = new int[10];
      for (int i=0; i<10; i++) {
          b[i] = a[i];
      }
  }
}

//좋은 예
public class Test {
  public void bar() {
      int[] a = new int[10];
      int[] b = new int[10];
      System.arraycopy(a, 0, b, 0, b.length);
  }
}
     ]]></example>
    </rule>
    <rule message="불필요한 Wrapper Object 생성" ref="rulesets/java/optimizations.xml/UnnecessaryWrapperObjectCreation">
        <description>
형변환을 위해 불필요한 Wrapper 메서드를 사용하는 것은 중복 인스턴스를 생성함으로써 메모리 자원을 낭비하고 성능 저하를 일으킨다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public int convert(String s) {
   int i, i2;

    i = Integer.valueOf(s).intValue();
    i2 = Integer.valueOf(i).intValue();
    String s3 = Integer.valueOf(i2).toString();

    return i2;
}

//좋은 예
public int convert(String s) {
    int i, i2;

    i = Integer.parseInt(s);
    i2 = i;
    String s3 = Integer.toString(i2);

    return i2;
}
     ]]></example>
    </rule>
    <rule message="내용이 없는 Catch 구문" ref="rulesets/java/empty.xml/EmptyCatchBlock">
        <description>
내용이 없는 예외 처리(catch 절)는 오류를 관리자가 인지 못하게 하여 치명적인 결함으로 이어질 수 있다.  최소한 오류가 발생했음을 알리는 로그는 출력해야 한다.
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
public void doSomething() {
    try {
        FileInputStream fis = new FileInputStream("/tmp/bugger");
    } catch (IOException ioe) {
         // 비어있는 catch블록
    }
}

//좋은 예
public void doSomething() {
    try {
        FileInputStream fis = new FileInputStream("/tmp/bugger");
    } catch (IOException ioe) {
         // 에러를 직접 처리하거나, 혹은 로그라도 남기도록 한다
         dealError();
         logger.error(ioe.getMessage(), ioe);
    }
}
     ]]></example>
    </rule>
    <rule message="비어있는 finally 구문" ref="rulesets/java/empty.xml/EmptyFinallyBlock">
        <description>
Finally 블록에서 아무 작업도 수행하지 않는다면 삭제한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    public void bar() {
        try {
            int x = 2;
        } finally {
            // 비어있는 finally 블록
        }
    }
}

//좋은 예
public class Foo {
    public void bar() {
        try {
            int x = 2;
        }
        // 비어있는 finally 블록 삭제
    }
}
     ]]></example>
    </rule>
    <rule message="비어 있는 if 구문" ref="rulesets/java/empty.xml/EmptyIfStmt">
        <description>
if 문에 내용이 없다면 해당 if 문이 필요가 없거나, 처리 로직이 없는 경우이다. 필요 없다면 삭제하고, 처리 로직이 필요하다면 구현한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    void bar(int x) {
        if (x == 0) {
            // 비어있는 if 블록
        }
        doSomething();
    }
}

//좋은 예
public class Foo {
    void bar(int x) {
        doSomething();
    }
}
     ]]></example>
    </rule>
    <rule message="Loop문 내의 필요없는 문장" ref="rulesets/java/empty.xml/EmptyStatementNotInLoop">
        <description>
Loop문 안의 내용 없이 비어 있는 구문은 보통 실수나 버그이므로 삭제한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void doit() {
    // 의도를 알수 없는 세미콜론
    ;
    // 세미콜론을 두번 기술함
    System.out.println("look at the extra semicolon");;
}

//좋은 예
public void doit() {
    System.out.println("good");
}
     ]]></example>
    </rule>
    <rule message="비어있는 try 구문" ref="rulesets/java/empty.xml/EmptyTryBlock">
        <description>
내용 없이 비어 있는 try 블록은 삭제 한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    public void bar() {
        try {
            // 내용이 없음
        } catch (Exception e) {
           e.printStackTrace();
        }
    }
}

//좋은 예
// try절을 비우지 않음
public class Foo {
    public void bar() {
        try {
            int x = 2;
        } catch (Exception e) {
             e.printStackTrace();
        }
    }
}
     ]]></example>
    </rule>
    <rule message="비어있는 While 구문" ref="rulesets/java/empty.xml/EmptyWhileStmt">
        <description>
Thread 를 지연시킬 목적으로 불필요한 while 반복문을 사용하는 것은 시스템 자원을 비효율적으로 소모하므로 사용하지  않는다. 대신 sleep() 메서드를 사용한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
void bar(int a, int b) {
    while (a == b) {
        // 스레드를 지연시키는 용도로 사용. ;만 있는 경우도 잘못된 사용임
    }
}

//좋은 예
void bar(int a, int b) {
    Thread.sleep(1000);
}
     ]]></example>
    </rule>
    <rule message="동일 패키지 범위 Import" ref="rulesets/java/imports.xml/ImportFromSamePackage">
        <description>
동일 패키지에 있는 클래스는 import로 가져오지 않아도 사용 가능하다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    package foo;

    import foo.Buz;
    import foo.*;

    public class Bar{}
}

//좋은 예
public void bar() {
    package foo;

    import foo.Buz;

    public class Bar{}
}
     ]]></example>
    </rule>
    <rule message="불필요한 임시 변환" ref="rulesets/java/unnecessary.xml/UnnecessaryConversionTemporary">
        <description>
기본 데이터(primitive type)를 String으로 변환할 때 불필요한 임시 변환 작업을 피하고 wrapper 클래스의 변환 메소드를 사용하도록 한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public String convert(int x) {
    String foo = new Integer(x).toString();
    return foo;
}

//좋은 예
public String convert(int x) {
    return Integer.toString(x);
}
     ]]></example>
    </rule>
    <rule message="사용하지 않는 파라미터" ref="rulesets/java/unusedcode.xml/UnusedFormalParameter">
        <description>
사용하지 않는 불필요한 메소드 파라미터는 삭제한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    private void bar(String howdy) {
        // 메소드내에서 howdy 사용되지 않음
    }
}

//좋은 예
public class Foo {
	// 메소드에서 쓰이지 않는 파라미터 받지 않음
    private void bar() {    
    }
}
     ]]></example>
    </rule>
    <rule message="사용되지 않는 Private Method" ref="rulesets/java/unusedcode.xml/UnusedPrivateMethod">
        <description>
사용되지 않는 private method는 삭제한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Something {
    private void foo() {} // 미사용
}

//좋은 예
public class Something {
    // 삭제
}
     ]]></example>
    </rule>
    <rule message="사용되지 않는 Private field" ref="rulesets/java/unusedcode.xml/UnusedPrivateField">
        <description>
사용되지 않는 private filed는 삭제한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Something {
    private static int FOO = 2; // 미사용
    private int i = 5; // 미사용
    private int j = 6;
    public int addOne() {
        return j++;
    }
}

//좋은 예
public class Something {
    private int j = 6;
    public int addOne() {
        return j++;
    }
}
     ]]></example>
    </rule>
    <rule message="주석없이 비어있는 Method" ref="rulesets/java/design.xml/UncommentedEmptyMethod">
        <description>
 내용 없이 비어있는 메소드에 주석이 있으면 어떤 의도로 만든 메소드인지 확인할 수 있다. 의도적으로 비워둔 메소드에는 내용을 주석으로 기록한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
// 주석없이 빈 메소드
public void doSomething() {
}

//좋은 예
public void doSomething() {
  // 메소드를 비워둔 명확한 이유를 주석으로 기술
}
     ]]></example>
    </rule>
    <rule message="코딩 표준과 어긋나는 변수 네이밍" ref="rulesets/java/naming.xml/VariableNamingConventions">
        <description>
 상수(final)는 대문자와 밑줄(_)만 사용해야 하며, 상수가 아닌 변수는 밑줄을 사용할 수 없다.
 logger는 오탐 처리 가능하며 패키지 인 경우 최소화 하여 처리
 
        </description>
		<!--
        <properties>
            <property name="violationSuppressXPath" value="ancestor::ClassOrInterfaceBodyDeclaration/FieldDeclaration/VariableDeclarator/VariableDeclaratorId[@Image='logger']" />
        </properties>
		-->
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    public static final int myNum = 0; // final 변수에 카멜케이스 사용
    public String MY_TEST = ""; // final이 아닌 변수에 언더스코어 사용
    DataModule DM_TEST = new DataModule(); // final이 아닌 객체에 언더스코어 사용
}

//좋은 예
public class Foo {
    public static final int MY_NUM = 0;
    public String myTest = "";
    DataModule dmTest = new DataModule();
}
     ]]></example>
    </rule>
    <!-- 1. 전자정부 0.1 기준 rule (기존 룰셋) 종료 -->

    <!-- 2. 룰 신규 추가 (20180309) -->
    <rule message="반복문 내의 Branching Statement 사용" ref="rulesets/java/basic.xml/AvoidBranchingStatementAsLastInLoop">
        <description>
반복문 마지막에 Branching Statement인 break, continue, return을 사용하지 않는다.
        </description>
        <priority>2</priority>
        <example><![CDATA[
//나쁜 예
// 오류는 발생하지 않으나, 좋은 방식은 아님
for (int i = 0; i < 10; i++) {
    if (i*i <= 25) {
        continue;
    }
    break;
}

//좋은 예
// 동일한 결과
for (int i = 0; i < 10; i++) {
    if (i*i <= 25) {
        break;
    }
}
     ]]></example>
    </rule>
    <rule message="잘못된 BigDecimal 초기화" ref="rulesets/java/basic.xml/AvoidDecimalLiteralsInBigDecimalConstructor">
        <description>
소수점 단위는 double형으로 정확히 표현되지 않는다. BigDecimal 생성 시에는 double형보다 String을 사용하여 생성/초기화하도록 한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    public static void main(String[] args) {
        BigDecimal bd = new BigDecimal(1.123);
    }
}

//좋은 예
public class Foo {
  public static void main(String[] args) {
    // String으로 생성
    BigDecimal bd = new BigDecimal("1.123");
    // 소수점 아래 단위가 없어 사용 가능
    BigDecimal bd = new BigDecimal(12);
  }
}
     ]]></example>
    </rule>
    <rule message="연속적인 단항연산자 사용" ref="rulesets/java/basic.xml/AvoidMultipleUnaryOperators">
        <description>
단항연산자를 연속적으로 사용하지 않는다. 중복되는 경우 최대한 간단하게 정리해서 표현한다.
        </description>
        <priority>2</priority>
        <example><![CDATA[
//나쁜 예
// 불필요하게 복잡하며 혼동을 줄 수 있는 코드
public void bar() {
  int i = - -1;
  int j = + - +1;
  int z = ~~2;
  boolean b = !!true;
  boolean c = !!!true;
}

//좋은 예
public void bar() {
  int i = -1;
  int j = -1;
  int z = 2;
  boolean b = true;
  boolean c = false;
}
     ]]></example>
    </rule>
    <rule message="java.lang.ThreadGroup 사용" ref="rulesets/java/basic.xml/AvoidThreadGroup">
        <description>
java.lang.ThreadGroup 은 되도록이면 사용하지 않는다. ThreadGroup 은 Threadsafe하지 않은 메소드를 포함한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Bar {
    void buz() {
        ThreadGroup tg = new ThreadGroup("My threadgroup") ;
        tg = new ThreadGroup(tg, "my thread group");
        tg = Thread.currentThread().getThreadGroup();
        tg = System.getSecurityManager().getThreadGroup();
    }
}

//좋은 예
// ThreadGroup을 사용하지 않는다.
     ]]></example>
    </rule>
    <rule message="IP주소 하드코딩" ref="rulesets/java/basic.xml/AvoidUsingHardCodedIP">
        <description>
소스 상에 IP Address를 하드 코딩 하지 않는다.
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    // IP 하드코딩
    private String ip = "127.0.0.1";
}

//좋은 예
public class Foo {
    private String ip = System.getProperty("example.ip");
}
     ]]></example>
    </rule>
    <rule message="0으로 시작하는 integer 입력" ref="rulesets/java/basic.xml/AvoidUsingOctalValues">
        <description>
0으로 시작하는 integer 값은 8진수로 저장된다. 의도하지 않은 결과를 가져오거나 혼동될 수 있으므로 이 같은 사용은 지양한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    int i = 012;  // i는 12가 아닌 10으로 인식
    int j = 010;  // i는 10이 아닌 8로 인식
    k = i * j;    // k는 120이 아닌 80으로 인식
}

//좋은 예
public void bar() {
    int i = 12;  // i는 12로 인식
    int j = 10;  // i는 10으로 인식
    k = i * j;   // k는 120으로 인식
}
     ]]></example>
    </rule>
    <rule message="존재하는 BigInteger/BigDecimal 생성" ref="rulesets/java/basic.xml/BigIntegerInstantiation">
        <description>
이미 존재하는 BigInteger, BigDecimal 인스턴스들은 생성하지 않는다. (예제 및 링크 참조)
https://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html
https://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public static void main(String[] args) {
    BigInteger bi=new BigInteger(1);
    BigInteger bi2=new BigInteger("0");
    BigInteger bi3=new BigInteger(0.0);
    BigInteger bi4;
    bi4=new BigInteger(0);
}


//좋은 예
public static void main(String[] args) {
    // 기존에 정의된 인스턴스를 사용한다.
    BigInteger.ZERO;
    BigInteger.ONE;
    BigInteger.TEN;
    BigDecimal.ZERO;
    BigDecimal.ONE;
    BigDecimal.TEN;

}
     ]]></example>
    </rule>
    <rule message="Boolean 객체 생성" ref="rulesets/java/basic.xml/BooleanInstantiation">
        <description>
Boolean 클래스는 new Boolean() 또는 Boolean.valueOf() 로 인스턴스화 할 필요 없이 Boolean.TRUE 또는 Boolean.FALSE로 대체할 수 있다.
        </description>
        <priority>2</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    public static void main(String[] args) {
        Boolean bar = new Boolean("true");
        Boolean buz = Boolean.valueOf(false);
    }
}

//좋은 예
public class Foo {
   public static void main(String[] args) {
       Boolean bar = Boolean.TRUE;
       Boolean buz = Boolean.FALSE;
   }
}
     ]]></example>
    </rule>
    <rule message="ResultSet 결과 미확인" ref="rulesets/java/basic.xml/CheckResultSet">
        <description>
ResultSet의 navigation method인 next, previous, first, last 를 사용할 경우 항상 return 값을 확인해야 한다. 실제로, false를 리턴 할 경우 이에 대한 처리 로직이 있어야 한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    Statement stat = conn.createStatement();
    ResultSet rst = stat.executeQuery("SELECT name FROM person");
    rst.next();  // false에 대한 처리가 없음
    String firstName = rst.getString(1);
}

//좋은 예
public void bar() {
    Statement stat = conn.createStatement();
    ResultSet rst = stat.executeQuery("SELECT name FROM person");
    if (rst.next()) {
        String firstName = rst.getString(1);
    } else {
        // false 처리 추가
    }
}
     ]]></example>
    </rule>
    <rule message="skip() 메소드 결과 미확인" ref="rulesets/java/basic.xml/CheckSkipResult">
        <description>
skip() 메소드는 파라미터로 넘긴 값보다 적은 stream을 skip할 수 있다. 반드시 실제 리턴된 값을 확인하여 처리하는 로직이 필요하다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    private FileInputStream _s = new FileInputStream("file");
    public void skip(int n) throws IOException {
        _s.skip(n);  // n만큼 skip 했는지 알 수 없음
    }
}

//좋은 예
public class Foo {
    private FileInputStream _s = new FileInputStream("file");
    public void skipExactly(int n) throws IOException {
        while (n != 0) {
            long skipped = _s.skip(n);
            if (skipped == 0) {
                throw new EOFException();
            }
            // 실제 skip된 값으로 처리하는 로직 추가
            n -= skipped;
        }
    }
}
     ]]></example>
    </rule>
    <rule message="연속된 if 구문" ref="rulesets/java/basic.xml/CollapsibleIfStatements">
        <description>
조건문 내의 중첩된 조건문 들은 하나의 조건문으로 변경 가능하다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
void bar() {
  if (x) {
    if (y) {
      // do stuff
    }
  }
}

//좋은 예
void bar() {
  if (x && y) {
    // do stuff
  }
}
     ]]></example>
    </rule>
    <rule message="Thread.run() 사용" ref="rulesets/java/basic.xml/DontCallThreadRun">
        <description>
Thread.run()  대신 Thread.start() 를 사용한다. run()은 Thread의 생성이 아닌 호출한 영역의 Thread 사용이다. start()를 통해 실제 native Thread를 생성하도록 한다.
        </description>
        <priority>4</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    Thredad t = new Thread();
    t.run();
}

//좋은 예
public void bar() {
    Thredad t = new Thread();
    t.start();
}
     ]]></example>
    </rule>
    <rule message="float형을 증감 변수로 사용" ref="rulesets/java/basic.xml/DontUseFloatTypeForLoopIndices">
        <description>
for문의 증감 변수로 float형을 사용하지 않는다. 성능 상의 이유 등, 반드시 사용해야 하는 경우에는 double형을 사용한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Count {
    public staic void main(String[] args) {
        final int START = 2000000000;
        int count = 0;
        for (float f = START; f < START + 50; f++) {
            count++;
        }
        // 0이 출력됨. (float)
        System.out.println(count);
        // 부동소수점으로 인한 반복문 오동작
    }
}

//좋은 예
public class Count {
    public staic void main(String[] args) {
        final int START = 2000000000;
        int count = 0;
        // 증감 변수로 int 사용
        for (int f = START; f < START + 50; f++) {
            count++;
        }
        System.out.println(count);
    }
}
     ]]></example>
    </rule>
    <rule message="Double Checked Locking" ref="rulesets/java/basic.xml/DoubleCheckedLocking">
        <description>
Double Checked Locking 패턴을 사용할 경우 불완전하게 생성된 객체를 반환할 위험이 있다. volatile로 선언하여 안전하게 동작하도록 작성한다.
 1. 객체가 null이면 객체를 등록하기 위하여 동기화 블록으로 진입한다.
 2. 동기화 블록 내에서 다시 한번 맴버 객체가 null인지 확인하고 객체를 생성한다.
 3. 2의 과정이 진행되는 동안 객체는 null인 상태가 아니므로 누군가 객체를 호출할 경우, 생성중인 불완전한 객체를 참조할 수 있다.
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    Object baz = null;
    Object bar() {
        if (baz == null) {  // baz가 null은 아니지만 완전하게 생성되지는 않음
            synchronized(this) {
                if (baz == null) {
                    baz = new Object();
                }
            }
        }
        return baz;
    }
}

//좋은 예
public class Foo {
    volatile Object baz = null;  // volatile 선언 (자바5 이상)
    Object bar() {
        if (baz == null) {
            synchronized(this) {
                if (baz == null) {
                    baz = new Object();
                }
            }
        }
        return baz;
    }
}
     ]]></example>
    </rule>
    <rule message="Object 객체 상속" ref="rulesets/java/basic.xml/ExtendsObject">
        <description>
Object 객체는 명시적으로 상속받을 필요 없다.
        </description>
        <priority>4</priority>
        <example><![CDATA[
//나쁜 예
public class Foo extends Object {  // 불필요한 상속
}

//좋은 예
public class Foo {
}
     ]]></example>
    </rule>
    <rule message="조건이 빠진 for문" ref="rulesets/java/basic.xml/ForLoopShouldBeWhileLoop">
        <description>
일부 조건들이 빠진 for문은 while문으로 변경 가능하며 코드를 간결하게 할 수 있다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    void bar() {
        for (;true;) {
        }
    }
}

//좋은 예
public class Foo {
    void bar() {
        // 초기화 및 증가 부분이 없는 for문은 while문으로 대체할 수 있다.
        while(true) {
        }
    }
}
     ]]></example>
    </rule>
    <rule message="증감 변수의 중복 사용" ref="rulesets/java/basic.xml/JumbledIncrementer">
        <description>
증감변수를 다수의 for문에서 동시에 사용하지 않도록 한다. 보통 실수로 많이 나타나고, 의도한 코딩이라 하더라도 혼동을 줄 수 있다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class JumbledIncrementerRule1 {
    public void foo() {
        for (int i = 0; i < 10; i++) {
            // 다른 for문에서 i를 증감변수로 사용하고 있음
            for (int k = 0; k < 20; i++) {
                System.out.println("Hello");
            }
        }
    }
}

//좋은 예
public class JumbledIncrementerRule1 {
    public void foo() {
        for (int i = 0; i < 10; i++) {
            for (int k = 0; k < 20; k++) {  // k로 변경
                System.out.println("Hello");
            }
        }
    }
}
     ]]></example>
    </rule>
    <rule message="equals() / hashCode() 메소드 override 누락" ref="rulesets/java/basic.xml/OverrideBothEqualsAndHashcode">
        <description>
equals()와 hashCode() 둘 중 한 메소드를 오버라이딩 해야 한다면 반드시 두 메소드 모두 오버라이딩 해야 한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Bar {  // hashCode() 오버라이딩 없음
    public boolean equals(Object o) {
    }
}

public class Baz {  // equals() 오버라이딩 없음
    public int hashCode() {
    }
}

//좋은 예
public class Foo {  // 두 메소드 모두 오버라이딩됨
    public boolean equals(Object other) {
        // do some comparison
    }
    public int hashCode() {
        // return some hash value
    }
}
     ]]></example>
    </rule>
    <rule message="finally 구문 return" ref="rulesets/java/basic.xml/ReturnFromFinallyBlock">
        <description>
finally block에서 리턴하는 로직을 피한다. 이는 발생된 exception을 무시할 가능성이 있다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Bar {
    public String foo() {
        try {
            // do something
        } catch (Exception e) {
            throw e;
        } finally {
            return "A.O.K";  // finally절에서 리턴
        }
    }
}

//좋은 예
public class Bar {
    public String foo() {
        try {
            // do something
        } catch (Exception e) {
            throw e;
        } finally {
            // return 처리 하지 않는다.
            // finally block이 비어있는 경우 삭제한다.
        }
        return "A.O.K";
    }
}
     ]]></example>
    </rule>
    <rule message="의미 없는 if문" ref="rulesets/java/basic.xml/UnconditionalIfStatement">
        <description>
조건이 항상 true/false 인 if문은 사용하지 않는다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    public void close() {
        // 고정된 조건의 의미없는 if문
        if (true) {
            // ...
        }
    }
}

//좋은 예
public class Foo {
    public void close() {
        // 의미없는 if문은 삭제한다.
        // ...
    }
}
     ]]></example>
    </rule>
    <rule message="Collection.toArray() 메소드 사용 시 파라미터 미지정" ref="rulesets/java/basic.xml/ClassCastExceptionWithToArray">
        <description>
특정 클래스가 담긴 Collection 객체로부터 Array를 얻어올 경우 Collection.toArray() 메소드의 파라미터로 특정 클래스의 배열형을 넘겨주어야 한다. 그렇지 않으면 ClassCastException이 발생한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    Collection c = new ArrayList();
    Integer obj = new Integer(1);
    c.add(obj);

    // ClassCastException 이 발생할 것임
    Integer[] a = (Integer [])c.toArray();
}

//좋은 예
public void bar() {
    Collection c = new ArrayList();
    Integer obj = new Integer(1);
    c.add(obj);

    Integer[] b = (Integer [])c.toArray(new Integer[0]);
    // 사이즈를 지정하는 것보다 0으로 선언하는게 더 효율적임
    // (OptimizableToArrayCall 룰 참조)
}
     ]]></example>
    </rule>
    <rule message="instanceof 사용 시 불필요한 null 체크" ref="rulesets/java/design.xml/SimplifyConditional">
        <description>
instanceof는 대상이 null일 경우 false를 리턴하므로, 별도의 null 체크를 수행할 필요 없다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
class Foo {
    void bar(Object x) {
        if (x != null && x instanceof Bar) {
        }
    }
}

//좋은 예
class Foo {
    void bar(Object x) {
        if (x instanceof Bar) {
        }
    }
}
     ]]></example>
    </rule>
    <rule message="생성자의 접근 제한자 확인" ref="rulesets/java/design.xml/AbstractClassWithoutAnyMethod">
        <description>
abstract 클래스에 아무 메소드도 없는 경우, 단순히 인스턴스 생성을 방지하기 위한 용도로 사용되는 것일 수 있다. (ex. 상수 클래스로 사용 등)
이런 경우 abstract로 선언하기 보다는 생성자를 private/protected로 만들어 인스턴스화 하지 못하도록 클래스를 선언하는 편이 더 나은 방법이다.
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
// 상수 클래스로 사용
public abstract class Example {
    String field = "TEST";
    int otherField = 123;
}

//좋은 예
public class Example {
    public static String field = "TEST";
    public static int otherField = 123;

    private Example() {
        // private을 선언하여 인스턴스화 방지
    }
}
     ]]></example>
    </rule>
    <rule message="" ref="rulesets/java/design.xml/AccessorClassGeneration">
        <description>
클래스 외부의 private 생성자를 사용한 객체 생성은 private 생성자를 포함한 클래스에 접근자 메소드를 구현하거나, factory method 또는 생성자의 비공유화로 해결한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Outer {
  void method(){
    Inner ic = new Inner();  // private 생성자는 클래스 외부에서 접근 불가
  }
  public class Inner {
    private Inner(){}
  }
}

//좋은 예
// factory method를 사용한 인스턴스 반환
public class Outer {
  void method(){
    Inner ic = Innser.getInstance();
  }
  public class Inner {
    private Inner(){}

    static public Inner getInstance() {
      if (instance == null) {
        instance = new Inner();
      }
      return instance;
    }
  }
}
     ]]></example>
    </rule>
    <rule message="Double.NaN 단순 비교" ref="rulesets/java/design.xml/BadComparison">
        <description>
Double.NaN과 비교하지 않는다. 부동 소수점 수 비교는 표현 정밀도가 부족하여 논리 오류를 발생시킬 수 있다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    boolean x = (errorValue == Double.NaN);
}

//좋은 예
public class Foo {
    // Double.isNaN() 메소드 사용
    boolean x = (Double.isNaN(errorValue));
}
     ]]></example>
    </rule>
    <rule message="private 생성자만 가지고 있는 클래스는 final로 변경" ref="rulesets/java/design.xml/ClassWithOnlyPrivateConstructorsShouldBeFinal">
        <description>
private 생성자만 가지고 있는 클래스는 final 클래스로 선언해야 한다.
- 단 private 생성자가 inner 클래스에서 호출되지 않을 경우에 한 함
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    private Foo() { }
}

//좋은 예
public final class Foo {  // final로 변경
    private Foo() { }
}
     ]]></example>
    </rule>
    <rule message="생성자에서 오버라이드 가능한 메소드 호출" ref="rulesets/java/design.xml/ConstructorCallsOverridableMethod">
        <description>
생성자에서 오버라이드 가능한 메소드를 호출하지 않는다. 오버라이드 가능한 메소드(toString 등)들을 생성자에서 호출하는 경우, 불완전하게 생성된 오브잭트를 호출하는 위험이 있을 수 있으며 이를 쉽게 확인하기 힘들다.
부모클래스를 상속하여 메소드 오버라이딩할 경우, 부모의 메소드는 더 이상 사용할 수 없다. 하위클래스에서 super()를 사용하여 부모클래스 생성자를 호출할 경우, 부모 생성자에 부모 메소드를 호출하는 부분이 포함되어 있다면 NullPointerException이 발생할 수 있다.
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
// 상위 클래스
public class SeniorClass {
    public SeniorClass() {
        // 하위클래스에서 toString()을 오버라이딩한 경우 NPE 발생 가능함
        toString();
    }
    public String toString(){
        return "IAmSeniorClass";
    }
}

public class JuniorClass extends SeniorClass {
    private String name;

    public JuniorClass() {
        super(); // toString()을 오버라이딩했으므로 NPE 발생함
        name = "JuniorClass";
    }

    public String toString() {
        return name.toUpperCase();
    }

    public static void main(String[] args) {
        JuniorClass jc = new JuniorClass();
    }
}

//좋은 예
// * 오버라이드 가능한 메소드를 호출하지 않거나,
//   메소드를 final 메소드로 만들어 처리한다.
//   (단 final 메소드로 만들 경우, 하위 클래스에서 오버라이딩 불가)

// 상위 클래스
public class SeniorClass {
    public SeniorClass() {
        //toString(); // 오버라이딩 메소드 삭제
    }

    // 또는 final 메소드로 변경
    //public final String toString() {
    public String toString() {
        return "IAmSeniorClass";
    }
}

public class JuniorClass extends SeniorClass {
    private String name;
    public JuniorClass(){
        name = "JuniorClass";
    }
    public String toString(){
        return name.toUpperCase();
    }
}
     ]]></example>
    </rule>
    <rule message="default 위치 확인" ref="rulesets/java/design.xml/DefaultLabelNotLastInSwitchStmt">
        <description>
switch 구문에서 default는 가장 마지막 부분에 작성한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    void bar(int a) {
        switch (a) {
        case 1:
            break;
        default:  // 중간에 위치함
            break;
        case 2:
            break;
        }
    }
}

//좋은 예
public class Foo {
    void bar(int a) {
        switch (a) {
        case 1:
            break;
        case 2:
            break;
        default:  // 마지막에 위치
            break;
        }
    }
}
     ]]></example>
    </rule>
    <rule message="내용이 없거나 자동 생성된 메소드는 abstract 설정" ref="rulesets/java/design.xml/EmptyMethodInAbstractClassShouldBeAbstract">
        <description>
내용이 없거나 자동 생성된 메소드는 abstract로 설정하여 하위 클래스 구현 시 부적절한 사용을 방지한다.
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
public abstract class ShouldBeAbstract {
    public Object couldBeAbstract() {
        return null;
    }
    public void couldBeAbstract() {
    }
}

//좋은 예
public abstract class Test {
    public abstract Object couldBeAbstract1();
    public abstract void couldBeAbstract2();
}
     ]]></example>
    </rule>
    <rule message="case절의 break/return 미사용" ref="rulesets/java/design.xml/MissingBreakInSwitch">
        <description>
switch 절에서 break나 return이 없는 case절은 의도하지 않은 결과를 발생시킬 수 있다. case절을 비워두는 경우 다음 case 절에서 break/return 등을 만나기 전까지 계속 실행된다. 만약 이같은 사용을 의도한 것이라면 별도의 주석을 남겨두도록 하자.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar(int status) {
    switch(status) {
        case CANCELLED:     // break 가 없어 다른 CASE 절까지 수행됨
            doCancelled();
        case NEW:   // break 가 없어 다른 CASE 절까지 수행됨
            doNew();
        case REMOVED:   // break 가 없어 다른 CASE 절까지 수행됨
            doRemoved();
        case OTHER;     // 내용이 없는 CASE - ERROR 케이스와 같은 로직을 수행하는지 확인 필요
        case ERROR:
            doErrorHandling();
            break;
    }
}

//좋은 예
public void bar(int status) {
    switch(status) {
        case CANCELLED:
            doCancelled();
            break;
        case NEW:
            doNew();
            break;
        case REMOVED:
            doRemoved();
            break;
        case OTHER:
            doSomething();
            break;
        case ERROR:
            doErrorHandling();
            break;
    }
}
     ]]></example>
    </rule>
    <rule message="Non-static 초기화 블록" ref="rulesets/java/design.xml/NonStaticInitializer">
        <description>
Non-static 초기화 블록은 생성자를 호출하기 직전에 실행된다. 잘못된 사용은 아니지만, 거의 사용되지 않는 방식으로 혼란을 줄 수 있다. 특별한 의도가 있는 것이 아니라면 사용하지 않도록 한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class MyClass {
    List<String> strs = new ArrayList<String>();
    // 생성자 이전에 실행되는 초기화 블록
    {
        strs.add("first");
        strs.add("second");
    }
    public MyClass () {
        // ...
    }
}

//좋은 예
public class MyClass {
    List<String> strs;
    private void intialize () {
        strs = new ArrayList<String>();
        strs.add("first");
        strs.add("second");
    }
    public MyClass () {
        initialize();
    }
}
     ]]></example>
    </rule>
    <rule message="thread-safe 하지 않은 싱글톤 사용" ref="rulesets/java/design.xml/NonThreadSafeSingleton">
        <description>
thread-safe하지 않은 싱글톤은 사용 시 정상적이지 않은 결과를 반환할 수 있다.
객체를 직접적으로 생성하는 static 싱글톤을 사용하지 않도록 하며 다음과 같이 사용한다.
 - static final로 선언 후 초기화 (initialize-on-demand holder 패턴 사용)
 - 메소드를 동기화하여 사용
또한 double-checked locking 패턴을 사용하지 않는다. volatile로 선언되지 않으면 정확한 동작을 보장하지 않는다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
// 호출이 동시에 여러 번 발생할 경우, 초기화가 정상적이지 않을 수 있음
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {     // 위험
            instance = new Singleton();
        }
        return instance;
    }
}

//좋은 예
//#1 - static final로 선언 후 초기화
public class Singleton {
    private static final Singleton instance = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }
}
//#1-2 - initialize-on-demand holder 패턴
public class Singleton {
    private Singleton() {}

    private static class LazyHolder {
        static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return LazyHolder.INSTANCE;
    }
}

//#2 - 메소드 동기화
class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
     ]]></example>
    </rule>
    <rule message="null 대신 비어있는 array 반환" ref="rulesets/java/design.xml/ReturnEmptyArrayRatherThanNull">
        <description>
배열을 반환하는 메서드의 경우 null이 아닌 빈 배열을 반환하는 것이 좋다. 빈 배열을 반환할 경우 모든 결과에 대해 null 여부를 확인하지 않아도 되며, 의도치 않게 발생하는 NullPointerException을 줄일 수 있다.
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
public class Example {
  public int[] badBehavior() {
    // null 반환
    return null;
  }
}

//좋은 예
public class Example {
  public String[] bonnePratique() {
    // 빈 배열 반환
    return new String[0];
  }
}
     ]]></example>
    </rule>
    <rule message="과도한 case 로직 처리" ref="rulesets/java/design.xml/SwitchDensity">
        <description>
switch 구문에서 case 하나에 과도하게 많은 로직을 넣지 않는다. 처리할 로직이 많을 경우 명령문을 새로운 메소드로 작성하거나 스위치 변수를 기반으로 서브 클래스를 작성하도록 한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    public void bar(int x) {
        switch (x) {
            case 1: {
                // 과도하게 많은 처리 로직
                break;
            } case 2: {
                // 과도하게 많은 처리 로직
                break;
            }
        }
    }
}

//좋은 예
public class Foo {
    public void bar(int x) {
        switch (x) {
            case 1: {
                // 별도의 메소드로 분리
                process(1);
                break;
            } case 2: {
                process(2);
                break;
            }
        }
    }
}
     ]]></example>
    </rule>
    <rule message="로컬 변수로 변경 가능" ref="rulesets/java/design.xml/SingularField">
        <description>
멤버 변수가 하나의 메소드에서만 사용되고 다른 메소드로 전달되지 않을 경우, 멤버 변수 보다는 해당 메소드 내의 로컬 변수로 선언하여 사용한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    // 명확한 이유 없이 멤버변수로 선언
    private int x;
    public void foo(int y) {
        x = y + 5;
        return x;
    }
}

//좋은 예
public class Foo {
    public void foo(int y) {
        int x = y + 5;  // 로컬변수로 선언
        return x;
    }
}
     ]]></example>
    </rule>
    <rule message="복잡한 중첩 if문" ref="rulesets/java/design.xml/AvoidDeeplyNestedIfStmts">
        <description>
복잡한 중첩 if문은 가독성이 떨어지고 오류를 초래하므로 사용하지 않도록 한다.
        </description>
        <properties>
            <property name="problemDepth" value="4" />
        </properties>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
   public void bar(int x, int y, int z) {
       if (x>y) {
           if (y>z) {
               if (z==x) {
                   // 복잡한 중첩 if문
               }
           }
       }
   }
}

//좋은 예
public class Foo {
   public void bar(int x, int y, int z) {
       if (x > y && y > z && z == x) {
           // 한 번에 처리
       }
   }
}
     ]]></example>
    </rule>
    <rule message="빈 문자열 사용" ref="rulesets/java/optimizations.xml/AddEmptyString">
        <description>
숫자를 문자열로 변환하기 위해 빈 문자열을 사용하는 것은 비효율적이다. Integer.toString() 메소드를 사용한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    String s = "" + 123;
}

//좋은 예
public void bar() {
    String s = Integer.toString(456);
}
     ]]></example>
    </rule>
    
    <rule message="불필요한 멤버 변수 초기화" ref="rulesets/java/optimizations.xml/RedundantFieldInitializer">
        <description>
자바의 멤버 변수가 기본(primitive) 타입일 경우 디폴트 값으로 자동 초기화된다. 기본값일 경우 명시적으로 지정하지 않도록 한다.
단 메소드 내의 로컬 변수는 명시적 초기화가 필요하다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class C {
    // 불필요하게 디폴트 값으로 초기화 하고있음
    boolean b   = false;
    byte by     = 0;
    short s     = 0;
    char c      = 0;
    int i       = 0;
    long l      = 0;

    float f     = .0f;
    double d    = 0d;
    Object o    = null;

    MyClass mca[] = null;
    int i1 = 0, ia1[] = null;

    class Nested {
        boolean b;
    }
}

//좋은 예
public class C {
    // 명시적으로 초기화하지 않아도 기본값으로 초기화됨
    boolean b;
    byte by;
    short s;
    char c;
    int i;
    long l;

    float f;
    double d;
    Object o;

    MyClass mca[];
    int i1, ia1[];

    // 메소드 내의 로컬 변수는 명시적 초기화가 필요함
    class Nested {
        boolean b = false;
    }
}
     ]]></example>
    </rule>
    <rule message="startsWith()를 charAt()으로 대체 가능" ref="rulesets/java/optimizations.xml/SimplifyStartsWith">
        <description>
startsWith() 메소드로 비교하는 문자열의 길이가 1이라면, charAt() 메소드를 사용하는 것이 더 빠르다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    boolean checkIt(String x) {
        return x.startsWith("a");
    }
}

//좋은 예
public class Foo {
    boolean fasterCheckIt(String x) {
        return x.charAt(0) == 'a';
    }
}
     ]]></example>
    </rule>
    <rule message="Vector 대신 ArrayList 사용" ref="rulesets/java/optimizations.xml/UseArrayListInsteadOfVector">
        <description>
Thread-safe하지 않아도 되는 경우라면, Vevtor 대신 ArrayList를 사용한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class SimpleTest extends TestCase {
    public void testX() {
        // Thread-safe해야 한다면 Vector 사용
        Collection c = new Vector();
    }
}

//좋은 예
public class SimpleTest extends TestCase {
    public void testX() {
        // Thread-safe하지 않아도 될 경우 ArrayList 사용
        Collection c = new ArrayList();
    }
}
     ]]></example>
    </rule>
    <rule message="List로 변환 시 asList() 메소드 사용" ref="rulesets/java/optimizations.xml/UseArraysAsList">
        <description>
객체의 배열(array)에서 List로 변환할 때 java.util.Arrays.asList 메소드를 사용한다. 반복문을 사용해서 객체를 직접 복사하는 것보다 더욱 빠르게 수행된다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Test {
    public void foo(Integer[] ints) {
        List<Integer> list = new ArrayList<>(100);
        for (int i=0; i< 100; i++) {
            list.add(ints[i]);
        }
        for (int i=0; i< 100; i++) {
            list.add(a[i].toString());
        }
    }
}

//좋은 예
public class Test {
    public void foo(Integer[] ints) {
        // 일반 배열에서 List 변환 시
        List<Integer> list = Arrays.asList(ints);

        // 일반 배열에서 ArrayList 변환 시
        ArrayList<Integer> arrayList = new ArrayList<Integer>(Arrays.asList(ints));
    }
}
     ]]></example>
    </rule>
    <rule message="문자열 연결 시 StringBuilder/StringBuffer 사용" ref="rulesets/java/optimizations.xml/UseStringBufferForStringAppends">
        <description>
문자열에 새로운 문자열을 더할 경우 +=를 사용하는 것보다 StringBuffer /StringBuilder를 사용하는 것이 더 빠르다.
 - StringBuffer : thread-safe
 - StringBuilder : thread-safe하지 않은 대신 StringBuffer 보다 빠름
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    void bar() {
        String a;
        a = "foo";
        a += " bar";
    }
}

//좋은 예
public class Foo {
    void bar() {
        StringBuilder a = new StringBuilder("foo");
        a.append(" bar");
    }
}
     ]]></example>
    </rule>
    <rule message="generic exception을 catch 구문에서 처리" ref="rulesets/java/strictexception.xml/AvoidCatchingGenericException">
        <description>
NullPointerException, RuntimeException, Exception 같은 generic exception을 catch절에서 처리하지 않는다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class PrimitiveType {
    public void downCastPrimitiveType() {
        try {
             System.out.println(" i [" + i + "]");
        } catch(Exception e) {
             e.printStackTrace();
        } catch(RuntimeException e) {
             e.printStackTrace();
        } catch(NullPointerException e) {
             e.printStackTrace();
        }
    }
}

//좋은 예
// 특정 Exception이나 사용자 정의 Exception 사용
public class CustomException extends Exception {
    // 사용자 Exception 정의
    // Exception 처리에 필요한 멤버, 메소드 등 구현
}

public class PrimitiveType {
    public void downCastPrimitiveType() {
        try {
            // 로직
        } catch(IOException e) {  // 특정 Exception 사용
            e.printStackTrace();
        } catch(CustomException e) { // 사용자 정의 Exception 사용
            e.printStackTrace();
        }
    }
}
     ]]></example>
    </rule>
    <rule message="Throwable을 catch절에서 처리" ref="rulesets/java/strictexception.xml/AvoidCatchingThrowable">
        <description>
Throwable을 catch절에서 처리하지 않는다. java.lang.Throwable은 모든 오류 및 예외에 대한 수퍼클래스이며, 이 객체로는 명확한 오류 처리를 수행할 수 없다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    try {
        // ...
    // 명확하지 않은 오류 처리
    } catch (Throwable th) {
        th.printStackTrace();
    }
}

//좋은 예
public void bar() {
    try {
        // ...
    // 특정 exception 명시
    } catch (MyException e) {
        e.printStackTrace();
    }
}
     ]]></example>
    </rule>
    <rule message="catch절 내의 의미없는 오류 객체 접근자 호출" ref="rulesets/java/strictexception.xml/AvoidLosingExceptionInformation">
        <description>
catch절에서 오류 객체의 접근자를 호출하고 아무런 작업도 하지 않는 것은 의미 없는 일이다. 이렇게 호출하는 부분을 삭제하거나, 접근자를 호출하여 반환된 결과를 오류 처리에 사용하도록 한다.
        </description>
        <priority>2</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    try {
         // do something
    } catch (SomeException se) {
         // 오류 메시지를 할당받는 부분이 없고 아무런 처리 하지 않음. 의미없는 코드..
         se.getMessage();
    }
}

//좋은 예
public void bar() {
    try {
         // do something
    } catch (SomeException se) {
         // LOGGER 출력하거나 다른 처리 로직을 넣는다.
         LOGGER.info("context", se.getMessage());
    }
}
     ]]></example>
    </rule>
    <rule message="동일 exception 객체 재전달" ref="rulesets/java/strictexception.xml/AvoidThrowingNewInstanceOfSameException">
        <description>
catch절에서 발생한 exception과 동일한 유형의 exception을 생성하여 전달하는 것은 코드 사이즈 및 런타임 복잡성만 증가시킨다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    try {
        // ...
    } catch (SomeException se) {
        // exception을 다시 던지는 것은 의미없음
        throw new SomeException(se);
    }
}

//좋은 예
public void bar() {
    try {
        // ...
    } catch (SomeException se) {
        // 로그를 남기는 등 오류에 대한 처리 수행
        LOGGER.info("context", se);
    }
}
     ]]></example>
    </rule>
    <rule message="Error 상속" ref="rulesets/java/strictexception.xml/DoNotExtendJavaLangError">
        <description>
Error는 시스템 exception 이므로 상속 받지 않는다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo extends Error { }

//좋은 예
public class Foo { }
     ]]></example>
    </rule>
    <rule message="finally절에서 exception 전달" ref="rulesets/java/strictexception.xml/DoNotThrowExceptionInFinally">
        <description>
finally절에서 exception을 발생시켜 전달하지 않는다. 또 다른 exception 또는 결함을 발생시킨다.
        </description>
        <priority>4</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    public void bar() {
        try {
            // 로직
        } catch( Exception e) {
            // 오류 처리
        } finally {
            // finally에서 exception 발생
            throw new Exception();
        }
    }
}

//좋은 예
public class Foo {
    public void bar() {
        try {
            // 로직
        } catch( Exception e) {
            // 오류 처리
        } finally {
            // do something
        }
    }
}
     ]]></example>
    </rule>
    <rule message="Flow 관리를 위한 exception 사용" ref="rulesets/java/strictexception.xml/ExceptionAsFlowControl">
        <description>
디버깅 시 오류 처리의 흐름을 관리하기 위해 exception을 사용하지 않는다. 유효성 검사를 추가하거나 대체 방안을 찾도록 한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    try {
         try {
              doSomething();
         } catch (Exception e) {
              throw new WrapperException(e);
         }
         doSomethingElse();
    } catch (WrapperException e) {
        // ...
    }
}

//좋은 예
public void bar1() {
    try {
        bar2();
        doSomethingElse();
    } catch (WrapperException e) {
        // ...
    }
}

private void bar2() {
    try {
        doSomething();
    } catch (Exception e) {
        // ...
    }
}
     ]]></example>
    </rule>
    <rule message="char를 String 형태로 append" ref="rulesets/java/strings.xml/AppendCharacterWithChar">
        <description>
StringBuffer / StringBuilder 클래스의 .append 메소드 사용 시 char를 String 형태로 사용하지 않는다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    StringBuffer sb = new StringBuffer();
    sb.append("a");
}

//좋은 예
public void bar() {
    StringBuffer sb = new StringBuffer();
    sb.append('a');
}
     ]]></example>
    </rule>
    <rule message="StringBuffer/StringBuilder를 멤버 변수로 사용" ref="rulesets/java/strings.xml/AvoidStringBufferField">
        <description>
StringBuffers / StringBuilders는 크기가 매우 커질 수 있고, 사용 시간이 길어질 경우 메모리 누수를 일으킬 수 있다. 멤버 변수로 사용하기 보다는 필요 시에 생성하여 사용하도록 한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    private StringBuffer buffer;
}

//좋은 예
public class Foo {
    public static void main(String[] args) {
        // 필요 시에 생성하여 사용
        StringBuffer sb = new StringBuffer(10);
        sb.append("sample..");
    }
}
     ]]></example>
    </rule>
    <rule message="개별적인 append() 사용" ref="rulesets/java/strings.xml/ConsecutiveAppendsShouldReuse">
        <description>
StringBuffer / StringBuilder 의 append()는 개별로 사용하는 것보다 연속적으로 사용하도록 한다. 연속적으로 사용할 경우 대상 객체를 재사용하므로 성능면에서 더 효율적이다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    String foo = " ";
    StringBuffer buf = new StringBuffer();

    buf.append("Hello"); // 개별 호출
    buf.append(foo);
    buf.append("World");
}

//좋은 예
public void bar() {
    String foo = " ";
    StringBuffer buf = new StringBuffer();

    // 연속적 호출
    buf.append("Hello").append(foo).append("World");
}
     ]]></example>
    </rule>
    <rule message="다수의 String 결합에 append() 사용" ref="rulesets/java/strings.xml/ConsecutiveLiteralAppends">
        <description>
여러 개의 String을 이어 붙이는 용도로 append()를 연속적으로 사용하지 않는다. 문자는 상수이므로 결합하여 String 형태로 한번의 호출로 완성하도록 한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    StringBuilder buf = new StringBuilder();
    buf.append("Hello").append(" ").append("World");
    buf.append('h').append('e').append('l').append('l').append('o');
    buf.append(1).append('m');
}

//좋은 예
public void bar() {
    StringBuilder buf = new StringBuilder();
    buf.append("Hello World");
    buf.append("hello");
    buf.append("1m");
}
     ]]></example>
    </rule>
    <rule message="StringBuffer/StringBuilder 사용 시 적절한 길이로 할당" ref="rulesets/java/strings.xml/InsufficientStringBufferDeclaration">
        <description>
StringBuffer와 StringBuilder는 실행 중에 빈번히 resize 작업이 수행된다. 예상되는 문자열 길이를 미리 할당하여 resize 작업이 최소화될 수 있도록 한다.
(* StringBuffer/StringBuilder 생성시 기본 할당 크기는 16 Character)
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    // 생성시 기본 할당 크기는 16이지만, 실제 입력된 문자열이 해당 크기를 넘어서므로 지속적인 사이즈 변경 작업이 수행됨.
    StringBuffer bad = new StringBuffer();
    bad.append("This is a long string that will exceed the default 16 characters");
}

//좋은 예
public void bar() {
    // 버퍼의 사이즈를 문자열 길이에 맞추어 미리 할당. 사이즈 변경 불필요.
    StringBuffer good = new StringBuffer(41);
    good.append("This is a long string, which is pre-sized");
}
     ]]></example>
    </rule>
    <rule message="StringBuffer 생성자에 char 사용" ref="rulesets/java/strings.xml/StringBufferInstantiationWithChar">
        <description>
StringBuffer 생성자 파라미터에 char를 넣어서 초기화하지 않는다. char는 int로 형변환 되어 StringBuffer의 size를 결정하는 용도로 사용된다. 'c'를 초기 값으로 사용하고 싶을 경우 "c"와 같이 String형으로 전달한다.
        </description>
        <priority>4</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    StringBuffer  sb1 = new StringBuffer('c');
    StringBuilder sb2 = new StringBuilder('c');
}

//좋은 예
public void bar() {
    StringBuffer  sb1 = new StringBuffer("c");
    StringBuilder sb2 = new StringBuilder("c");
}
     ]]></example>
    </rule>
    <rule message="불필요한 대문자화/소문자화" ref="rulesets/java/strings.xml/UnnecessaryCaseChange">
        <description>
대소문자 구분이 필요없을 경우, toUpperCase/toLowerCase().equals() 을 사용하는 것보다 equalsIgnoreCase() 메소드를 사용하는 것이 더 빠르다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    boolean answer1 = buz.toUpperCase().equals("baz");
    boolean answer2 = buz.toUpperCase().equalsIgnoreCase("baz");
}

//좋은 예
public void bar() {
    boolean answer1 = buz.equalsIgnoreCase("baz");
    boolean answer2 = buz.equalsIgnoreCase("baz");
}
     ]]></example>
    </rule>
    <rule message="문자열(String) 비교 시 ==, != 사용" ref="rulesets/java/strings.xml/UseEqualsToCompareStrings">
        <description>
String 객체 비교에는 equals 메소드를 사용한다. ==, !=를 사용하여 String을 비교하지 않는다. (비교 대상 둘 다 intern 버전일 경우 비교 가능함)
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public boolean test(String s) {
    if (s == "one") return true;
    return false;
}

//좋은 예
public boolean test(String s) {
    if ("two".equals(s)) return true;
    return false;
}
     ]]></example>
    </rule>
    <rule message="String.indexOf(String) 대신 String.indexOf(char) 사용" ref="rulesets/java/strings.xml/UseIndexOfChar">
        <description>
한 글자(Single Character)의 위치를 확인할 경우, String.indexOf(String) 보다 String.indexOf(char) 가 더 빠르다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    String s = "hello world";
    if (s.indexOf("d") {}
}

//좋은 예
public void bar() {
    String s = "hello world";
    if (s.indexOf('d') {}
}
     ]]></example>
    </rule>
    <rule message="String으로 변환하여 문자열 길이 확인" ref="rulesets/java/strings.xml/UseStringBufferLength">
        <description>
StringBuffer의 길이를 구할 때 String으로 변환시켜 길이를 구하는 것은 비효율적이다. StringBuffer.length() 를 사용한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    StringBuffer sb = new StringBuffer();
    if (sb.toString().equals("")) {}
}

//좋은 예
public void bar() {
    StringBuffer sb = new StringBuffer();
    if (sb.length() == 0) {}
}
     ]]></example>
    </rule>
    <rule message="java.lang 패키지 import" ref="rulesets/java/imports.xml/DontImportJavaLang">
        <description>
java.lang의 클래스는 자동으로 import 되므로 java.lang에 포함되는 클래스는 명시적으로 import 하지 않는다.
        </description>
        <priority>4</priority>
        <example><![CDATA[
//나쁜 예
// java.lang는 자동 import임
import java.lang.String;
import java.lang.*;

public class Foo {
  public String str;
}

//좋은 예
// java.lang 따로 import하지않고 필요한 사항만 import
package test.sample;

import test.sample2.someThing;

public class Foo {
  public String str;
  public SomeThing something;
}
     ]]></example>
    </rule>
    <rule message="사용되지 않는 클래스 import" ref="rulesets/java/imports.xml/UnusedImports">
        <description>
사용되지 않는 클래스 Import는 삭제하고 com.foo.* 형태의 import를 하지 않는다.
* Eclipse 설정 활용 : 설정의 Java - Editor - Save Action에서 Organize Imports 체크 활성화
        </description>
        <priority>4</priority>
        <example><![CDATA[
//나쁜 예
package test.sample;

import java.io.File;              // 사용안함
import java.util.*;               // 사용안함
import test.sample2.SomeThing;
import test.sample2.SomeThing;    // 중복

public class Foo {
    public String str;
    public SomeThing someThing;
}

//좋은 예
package test.sample;

import test.sample2.someThing;

public class Foo {
    public String str;
    public SomeThing something;
}
     ]]></example>
    </rule>
    <rule message="CloneNotSupportedException throw 하도록 구현" ref="rulesets/java/clone.xml/CloneThrowsCloneNotSupportedException">
        <description>
clone() 메소드는 CloneNotSupportedException을 throw 하도록 구현한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class MyClass implements Cloneable{
    public Object clone() { // 에러 발생
        MyClass clone = (MyClass)super.clone();
        return clone;
    }
}

//좋은 예
public class MyClass implements Cloneable{
    public Object clone() throws CloneNotSupportedException {
        MyClass clone = (MyClass)super.clone();
        return clone;
    }
}
     ]]></example>
    </rule>
    <rule message="short 대신 int 사용" ref="rulesets/java/controversial.xml/AvoidUsingShortType">
        <description>
short 타입 계산 시 JVM 내부적으로 int로 변환하여 계산하고, 그 결과를 다시 short 타입으로 변환한다.
성능 향상을 위해 short 대신 int 를 사용하도록 한다.
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
public class UsingShort {
    private short doNotUseShort = 0;

    public UsingShort() {
        short shouldNotBeUsed = 1;
        doNotUseShort += shouldNotBeUsed;
    }
}

//좋은 예
// short 대신 int 사용
public class UsingInt {
    private int doNotUseShort = 0;

    public UsingShort() {
        int shouldNotBeUsed = 1;
        doNotUseShort += shouldNotBeUsed;
    }
}
     ]]></example>
    </rule>
    <rule message="과도한 크기의 클래스 파일" ref="rulesets/java/codesize.xml/ExcessiveClassLength">
        <description>
매우 긴 길이의 클래스 파일은 많은 기능을 포함하여, 클래스 작동 시 위험 요소가 될 가능성이 많다. 분리 가능한 부분을 나누고 코드 사이즈를 줄여 관리가 용이하고 재사용할 수 있는 코드로 변경한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    public void bar() {
        // 1000 라인 이상의 코드
    }
}

//좋은 예
public class Foo {
    // 기능 별로 메소드 분리
    public void bar1() {
        // 기능1
    }

    public void bar2() {
        // 기능2
    }

    public void bar3() {
        // 기능3
    }
}
     ]]></example>
    </rule>
    <rule message="비어있는 synchronized 구문" ref="rulesets/java/empty.xml/EmptySynchronizedBlock">
        <description>
내용이 없는 synchronized blocks은 삭제한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
    public void bar() {
        // 내용 없음
        synchronized (this) {
        }
    }
}

//좋은 예
public class Foo {
    public void bar() {
        // 불필요한 synchronized block 삭제
    }
}
     ]]></example>
    </rule>
    <rule message="너무 긴 변수명" ref="rulesets/java/naming.xml/LongVariable">
        <description>
너무 긴 멤버 변수명, 로컬 변수명, 파라미터명은 코드 확인을 어렵게 한다. (현 기준 : 24글자 이하로 작성)
상수인 경우는 24자 이상일 경우 오탐처리 허용
        </description>
        <priority>3</priority>
        <properties>
           <property name="minimum" value="24" />
           <!-- <property name="violationSuppressXPath" value="//FieldDeclaration[@Static='true' and @Final='true']" /> -->
        </properties>
        <example><![CDATA[
//나쁜 예
public class Something {
    int reallyLongIntName = -3;
    public static void main( String argumentsList[] ) {
        int otherReallyLongName = -5;
        for (int interestingIntIndexTooLongName = 0;
                 interestingIntIndexTooLongName < 10;
                 interestingIntIndexTooLongName ++ ) {
        }
    }
}

//좋은 예
public class Something {
    int baz = -3;
    public static void main( String args[] ) {
        int buz = -5;
        for (int i = 0; i < 10; i++) {
        }
    }
}
     ]]></example>
    </rule>
    <rule message="Vector 대신 java.util.ArrayList 사용" ref="rulesets/java/migrating.xml/ReplaceVectorWithList">
        <description>
Thread-safe하지 않아도 되는 경우라면, Vevtor 대신 ArrayList를 사용한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class SimpleTest extends TestCase {
    public void testX() {
        // Thread-safe해야 한다면 Vector 사용
        Collection c = new Vector();
    }
}


//좋은 예
public class SimpleTest extends TestCase {
    public void testX() {
        // Thread-safe하지 않아도 될 경우 ArrayList 사용
        Collection c = new ArrayList();
    }
}
     ]]></example>
    </rule>
    <rule message="로깅 시 파라미터 부족" ref="rulesets/java/logging-jakarta-commons.xml/UseCorrectExceptionLogging">
        <description>
전체 stacktrace를 확인하기 위해서는 로그 메소드의 파라미터로 메시지 String, Throwable 객체 2개가 필요하다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Main {
    private static final Log _LOG = LogFactory.getLog( Main.class );
    void bar() {
        try {
        } catch( Exception e ) {
            _LOG.error( e );
        }
    }
}

//좋은 예
public class Main {
    private static final Log _LOG = LogFactory.getLog( Main.class );
    void bar() {
        try {
        } catch( Exception e ) {
            // arguments 2개 전달 (메시지 String, Throwable 객체)
            _LOG.error( oe.getMessage(), oe );
        }
    }
}
     ]]></example>
    </rule>
    <rule message="bean의 모든 멤버변수는 직렬화 가능해야 함" ref="rulesets/java/javabeans.xml/BeanMembersShouldSerialize">
        <description>
bean 클래스의 모든 멤버 변수는 직렬화(serializable) 가능해야 한다.
 1. getter/setter 메소드 추가하여 멤버 변수에 접근할 수 있도록 조치
 2. static 키워드로 선언
 3. transient 키워드로 선언 : 직렬화/역직렬화 시 사용되지 않는 경우라면 값이 전달되지 않도록 transient 선언
 * 상수(static final 등)로 쓰이는 형태가 아닌 경우, 되도록이면 멤버 변수는 사용하지 않는다.
 * Resource , Autowired , Value 등 서비스를 위한 변수는 테스트 후 오탐처리 가능
        </description>
        <priority>3</priority>
		<!--
        <properties>
            <property name="violationSuppressXPath" value="ancestor::ClassOrInterfaceBodyDeclaration/Annotation/MarkerAnnotation/Name[@Image='Resource' or @Image='Autowired'] |
                ancestor::ClassOrInterfaceBodyDeclaration/Annotation/NormalAnnotation/Name[starts-with(@Image, 'Resource') or starts-with(@Image, 'Autowired')] |
                ancestor::ClassOrInterfaceBodyDeclaration/Annotation/SingleMemberAnnotation/Name[@Image='Value']" />
            </properties>
		-->	
        <example><![CDATA[
//나쁜 예
private transient int someFoo;
private static int otherFoo;
private int moreFoo;
private int badFoo;              // 필요없다면 transient 선언 필요

private void setMoreFoo(int moreFoo){
    this.moreFoo = moreFoo;
}

private int getMoreFoo(){
    return this.moreFoo;
}

//좋은 예
private transient int someFoo;   // transient 선언됨
private static int otherFoo;     // static 선언됨
private int moreFoo;             // getter, setter 메소드 존재

private void setMoreFoo(int moreFoo){
    this.moreFoo = moreFoo;
}

private int getMoreFoo(){
    return this.moreFoo;
}
     ]]></example>
    </rule>
    <rule message="HTML 주석 사용" ref="rulesets/jsp/basic.xml/NoHtmlComments">
        <description>
JSP 작성 시 HTML 주석보다 JSP 주석을 사용하도록 한다.
        </description>
        <priority>2</priority>
        <example><![CDATA[
//나쁜 예
<HTML><title>bad example<BODY>
<!-- HTML comment -->
</BODY> </HTML>

//좋은 예
<HTML><title>good example<BODY>
<%-- JSP comment --%>
</BODY> </HTML>
     ]]></example>
    </rule>
    <rule message="인라인 스크립트 사용" ref="rulesets/jsp/basic.xml/NoInlineScript">
        <description>
인라인 스크립트 사용을 피하고 sctipt 태그의 src로 외부 스크립트를 지정하여 사용하도록 한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
<a href="#" onclick="$(this).next().fadeIn(); return false;">inline test</a>

//좋은 예
<script type="text/javascript" src="/js/common/common.js"></script>
     ]]></example>
    </rule>
    <rule message="style 관련 설정은 css 파일에 기술하며, tag나 attributes 사용은 지양한다." ref="rulesets/jsp/basic.xml/NoInlineStyleInformation">
        <description>
스타일 관련 설정은 css 파일에 있어야 한다. tag나 attributes를 사용하여 style 설정하지 않는다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
<html><body><p align='center'><b>text</b></p></body></html>

//좋은 예
// css를 별도의 파일로 분리
// html
<head>
<link rel="stylesheet" href="style.css">
</head>
<body>
  <p>text</p>
</body>

// css
p {text-align: center; font-weight:bold}
     ]]></example>
    </rule>
    <rule message="forward 사용" ref="rulesets/jsp/basic.xml/NoJspForward">
        <description>
JSP에서 forward 기능을 사용하여 이동하지 않는다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
<jsp:forward page='UnderConstruction.jsp'/>

//좋은 예
//sendRedirect 사용
<%
    response.sendRedirect("/jsp/main.jsp");
%>
     ]]></example>
    </rule>
    <rule message="JSP 내부에 script 기술" ref="rulesets/jsp/basic.xml/NoLongScripts">
        <description>
script를 JSP 내부에 직접 기술하지 않고 Tag 라이브러리로 정의하여 사용한다.
        </description>
        <priority>2</priority>
        <example><![CDATA[
//나쁜 예
<HTML>
<BODY>
<!--Java Script-->
<SCRIPT language="JavaScript" type="text/javascript">
function calcDays(){
    var date1 = document.getElementById('d1').lastChild.data;
    var date2 = document.getElementById('d2').lastChild.data;
    date1 = date1.split("-");
    date2 = date2.split("-");
    var sDate = new Date(date1[0]+"/"+date1[1]+"/"+date1[2]);
    var eDate = new Date(date2[0]+"/"+date2[1]+"/"+date2[2]);
    var daysApart = Math.abs(Math.round((sDate-eDate)/86400000));
    document.getElementById('diffDays').lastChild.data = daysApart;
}

onload=calcDays;
</SCRIPT>
</BODY>
</HTML>

//좋은 예
// script를 별도의 파일로 분리
<HTML>
<BODY>
  <script type="text/javascript" src="script.js"></script>
</BODY>
</HTML>
     ]]></example>
    </rule>
    <rule message="JSP 내부에 script 기술" ref="rulesets/jsp/basic.xml/NoScriptlets">
        <description>
Script를 JSP 내부에 직접 기술하지 않고 Tag 라이브러리나 JSP declarations으로 정의한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
<HTML>
<HEAD>
<%
response.setHeader("Pragma", "No-cache");
%>
</HEAD>
  <BODY>
    <jsp:scriptlet>String title = "Hello world!";</jsp:scriptlet>
  </BODY>
</HTML>

//좋은 예
// JSTL 사용
<%@ taglib uri='http://java.sun.com/jsp/jstl/core' prefix='c' %>
<c:set var="title" value="Hello world!" />
     ]]></example>
    </rule>
    <rule message="escaping/sanitizing 처리 없음" ref="rulesets/jsp/basic.xml/NoUnsanitizedJSPExpression">
        <description>
escaping / sanitizing 처리 없이 JSP EL을 사용하지 않는다. XSS 공격의 원인이 될 수 있다.
 - escaping / sanitizing: HTML 태그 등에 사용되는 특수 문자를 안전한 문자열로 변경 또는 제거하는 작업
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
<%@ page contentType="text/html; charset=UTF-8" %>
<%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>
${expression}                    <!-- 잘못된 방식 -->

//좋은 예
<%@ page contentType="text/html; charset=UTF-8" %>
<%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>
${fn:escapeXml(expression)}      <!-- escape 처리 -->
<c:out value="${expression}" />  <!-- 또는 c:out 사용 -->
     ]]></example>
    </rule>
    <rule message="src가 지정되지 않은 IFrame 태그" ref="rulesets/jsp/basic.xml/IframeMissingSrcAttribute">
        <description>
SSL 연결에서 src가 지정되지 않은 IFrame 태그는 보안경고 팝업을 띄울 수 있다. (Internet Explorer)
        </description>
        <priority>2</priority>
        <example><![CDATA[
//나쁜 예
<HTML><title>bad example><BODY>
<iframe></iframe>
</BODY> </HTML>

//좋은 예
<HTML><title>good example><BODY>
<iframe src="foo"></iframe>
</BODY> </HTML>
     ]]></example>
    </rule>
    <rule message="JSP 인코딩 설정하지 않음" ref="rulesets/jsp/basic.xml/JspEncoding">
        <description>
meta 태그 등을 사용한 JSP 인코딩 설정은 반드시 사용한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
// meta tag 및 page 설정 없음
// meta tag 생략
<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" %>

//좋은 예
<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" %>
<meta http-equiv="Content-Type"  content="text/html; charset=UTF-8" />
     ]]></example>
    </rule>
    <rule message="중복 import (JSP)" ref="rulesets/jsp/basic.xml/DuplicateJspImports">
        <description>
JSP에서 중복 import 하지 않는다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
<%@ page import=\"com.foo.MyClass,com.foo.MyClass\"%><html><body><b><img src=\"<%=Some.get()%>/foo\">xx</img>text</b></body></html>

//좋은 예
<%@ page import=\"com.foo.MyClass\"%><html><body><b><img src=\"<%=Some.get()%>/foo\">xx</img>text</b></body></html>
     ]]></example>
    </rule>
    <rule message="parseInt()에서 radix(진수) 설정" ref="rulesets/ecmascript/basic.xml/UseBaseWithParseInt">
        <description>
parseInt()에서 두번째 파라미터인 radix(진수)을 생략하지 않는다. 기본값은 10으로 10진수 값을 반환하지만, 되도록이면 명시적으로 radix를 지정하여 예상 결과값을 명확히 한다.
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
function useBaseWithParseInt() {
    // default는 10진법이기 때문에 10으로 출력되나 명확하지 않음
    var value = parseInt("010");
    console.log(value);
}

//좋은 예
function useBaseWithParseInt() {
    // 10진법을 명시적으로 설정
    var value = parseInt("010", 10);
    console.log(value);
}
     ]]></example>
    </rule>
    <rule message="for-in 구문 변수 사용" ref="rulesets/ecmascript/basic.xml/ScopeForInVariable">
        <description>
javascript for-in 구문에서는 변수를 var로 선언하거나(로컬 변수) 임시 변수명을 사용한다.
var로 선언하지 않을 경우 동일한 이름으로 선언된 for-in 외부의 변수에 영향을 끼칠 수 있다.
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
function bar() {
    var p = 'clean';
    function() {
        var obj = { dirty: 'dirty' };
        for (p in obj) { // 외부의 변수 p를 사용함
          obj[p] = obj[p];
        }
        return x;
    }();
    // p에는 dirty 값이 들어가게 된다.
}

//좋은 예
function foo() {
    var p = 'clean';
    function() {
        var obj = { dirty: 'dirty' };
        // var로 선언되어 for-in 안에서만 사용됨
        for (var p in obj) {
          obj[p] = obj[p];
        }
        return x;
    }();
    // for-in 바깥의 변수 p는 'clean' 값을 가지고 있다.
}
     ]]></example>
    </rule>
    <rule message="return/break/continue/throw 키워드 뒤에 위치한 코드" ref="rulesets/ecmascript/basic.xml/UnreachableCode">
        <description>
‘return’, ‘break’, ‘continue’, ‘throw’ 문은 코드 블락의 마지막 부분에 위치해야 한다.
해당 키워드 뒤에 작성된 코드는 실행되지 않는다.
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
function bar() {
    var x = 1;
    return x;
    x = 2;
}

//좋은 예
function foo() {
    var x = 1;
    return x;
}
     ]]></example>
    </rule>
    <rule message="전역 변수 사용" ref="rulesets/ecmascript/basic.xml/GlobalVariable">
        <description>
javascript에서 global 변수 사용을 지양한다. global 변수는 발견하기 힘든 오동작을 불러일으킨다.
        </description>
        <priority>1</priority>
        <example><![CDATA[
//나쁜 예
function foo(arg) {
  // var 로 선언하지 않아 global 변수로 생성됨.
  notDeclaredVariable = 1;
}

//좋은 예
function bar(arg) {
  var someVar = 1; // 로컬 변수로 생성
  window.otherGlobal = 2; // global 변수지만, 이런 방식은 허용됨
}
     ]]></example>
    </rule>
    <rule message="for문 중괄호 생략" ref="rulesets/ecmascript/braces.xml/ForLoopsMustUseBraces">
        <description>
코드가 단 한 줄만 있더라도 소스코드의 구역을 제대로 구분할 수 있도록 괄호{ } 를 반드시 사용한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
for (var i = 0; i < 42; i++)
    foo();

//좋은 예
for (var i = 0; i < 42; i++) {
    foo();
}
     ]]></example>
    </rule>
    <rule message="if else문 중괄호 생략" ref="rulesets/ecmascript/braces.xml/IfElseStmtsMustUseBraces">
        <description>
코드가 단 한 줄만 있더라도 소스코드의 구역을 제대로 구분할 수 있도록 괄호{ } 를 반드시 사용한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    if (foo)
        x++;
    else
        y++;
}

//좋은 예
public void bar() {
    if (foo) {
        x++;
    } else {
        y++;
    }
}
     ]]></example>
    </rule>
    <rule message="if문 중괄호 생략" ref="rulesets/ecmascript/braces.xml/IfStmtsMustUseBraces">
        <description>
코드가 단 한 줄만 있더라도 소스코드의 구역을 제대로 구분할 수 있도록 괄호{ } 를 반드시 사용한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public void bar() {
    if (foo)
        x++;
}

//좋은 예
public void bar() {
    if (foo) {
        x++;
    }
}
     ]]></example>
    </rule>
    <rule message="높은 복잡도" ref="rulesets/java/codesize.xml/CyclomaticComplexity">
        <description>
메서드의 복잡도는 유지 관리 비용과 코드 가독성에 직접접인 영향을 끼친다.
하나의 메소드에 과도한 결정 포인트가 있을 경우 메소드의 동작을 파악하거나 변경하는 것이 매우 어렵기 때문이다.

Cyclomatic complexity는 메소드에 존재하는 결정 포인트 수와 메소드 진입 수를 계산하여 메소드의 복잡도를 계산한다.
- 결정 포인트 : 제어 흐름이 프로그램의 다른 위치로 점프하는 곳으로 if, while, for 및 case와 같은 모든 제어 흐름 명령문을 포함.

계산된 수치에 따라 다음과 같이 복잡도가 구분된다.
 - 1 ~ 4 : 낮은 복잡도
 - 5 ~ 7 : 중간 복잡도
 - 8 ~ 10 : 높은 복잡도
 - 11 이상 : 매우 높은 복잡도

PMD에서는 복잡도 10 이상인 메소드를 찾아 보고한다.
또한 10 이상인 메소드가 없더라도, 메소드 복잡도 합계가 80인 클래스는 중간 복잡도를 가진 클래스로 보고한다.

높은 복잡도의 메소드 및 클래스는 기능적으로 분리하는 것을 검토한다.
        </description>
        <properties>
            <property name="showMethodsComplexity" value="true" />
            <property name="reportLevel"  value="15" />
            <property name="showClassesComplexity"  value="false" />
        </properties>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
public class Foo {
1   void baseCyclo() {  // 복잡도 = 1
        highCyclo();
    }

1   void highCyclo() {  // 복잡도 10 (높은 복잡도)
        int x = 0, y = 2;
        boolean a = false, b = true;

3       if (a && (y == 1 ? b : true)) {  // +2
4           if (y == x) {                // +1
5               while (true) {           // +1
6                   if (x++ < 20) {      // +1
7                       break;           // +1
                    }
                }
9           } else if (y == t && !d) {   // +2
10              x = a ? y : x;           // +1
            } else {
                x = 2;
            }
        }
    }
}

public class Foo {    // 복잡도 12 (높은 복잡도)
1   public void example()  {
2       if (a == b)  {
3           if (a1 == b1) {
                fiddle();
4           } else if a2 == b2) {
                fiddle();
            }  else {
                fiddle();
            }
5       } else if (c == d) {
6           while (c == d) {
                fiddle();
            }
7        } else if (e == f) {
8           for (int n = 0; n < h; n++) {
                fiddle();
            }
        } else{
            switch (z) {
9               case 1:
                    fiddle();
                    break;
10              case 2:
                    fiddle();
                    break;
11              case 3:
                    fiddle();
                    break;
12              default:
                    fiddle();
                    break;
            }
        }
    }
}

//좋은 예
// 프로세스를 파악하여 기능을 분리할 수 있는지 검토한다.
// 가능하다면 소규모의 모듈로 분리한다.
     ]]></example>
    </rule>
    <rule message="잘못된 CDATA 섹션" ref="rulesets/xml/basic.xml/MistypedCDATASection">
        <description>
XML의 CDATA 섹션은 &lt;!CDATA[ 로 시작해서 ]]&gt;로 끝난다. [ ] 의 개수에 주의한다.
 - 시작 : &lt;!CDATA[ - [ 이 1개
 - 종료 : ]]&gt; - ]이 2개
        </description>
        <priority>3</priority>
        <example>
//나쁜 예
&lt;CDATA[]]&gt; : 잘못된 [ 표현
&lt;CDATA[]]&gt; : 잘못된 ] 표현

//좋은 예
&lt;CDATA[[]]&gt; : [ 표현
&lt;CDATA[]]]&gt; : ] 표현
    </example>
    </rule>
    <rule message="높은 복잡도" ref="rulesets/plsql/codesize.xml/CyclomaticComplexity">
        <description>
메서드의 복잡도는 유지 관리 비용과 코드 가독성에 직접접인 영향을 끼친다.
하나의 메소드에 과도한 결정 포인트가 있을 경우 메소드의 동작을 파악하거나 변경하는 것이 매우 어렵기 때문이다.

Cyclomatic complexity는 메소드에 존재하는 결정 포인트 수와 메소드 진입 수를 계산하여 메소드의 복잡도를 계산한다.
- 결정 포인트 : 제어 흐름이 프로그램의 다른 위치로 점프하는 곳으로 if, while, for 및 case와 같은 모든 제어 흐름 명령문을 포함.

계산된 수치에 따라 다음과 같이 복잡도가 구분된다.
 - 1 ~ 4 : 낮은 복잡도
 - 5 ~ 7 : 중간 복잡도
 - 8 ~ 10 : 높은 복잡도
 - 11 이상 : 매우 높은 복잡도

PMD에서는 복잡도 10 이상인 메소드를 찾아 보고한다.
또한 10 이상인 메소드가 없더라도, 메소드 복잡도 합계가 80인 클래스는 중간 복잡도를 가진 클래스로 보고한다.

높은 복잡도의 메소드 및 클래스는 기능적으로 분리하는 것을 검토한다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
//나쁜 예
-- 복잡도 11
CREATE OR REPLACE PACKAGE BODY pkg_pmd_working_sequence  AS
1 PROCEDURE ty_logger  IS BEGIN
2    IF true THEN
        DBMS_OUTPUT.PUT_LINE('IF/THEN l_Integer='||l_integer);

3       IF true
        THEN
             DBMS_OUTPUT.PUT_LINE('IF/THEN l_Integer='||l_integer);
4           IF true
            THEN
                 DBMS_OUTPUT.PUT_LINE('IF/THEN l_Integer='||l_integer);
5           ELSIF false
            THEN
               DBMS_OUTPUT.PUT_LINE('ELSIF l_Integer='||l_integer);
            ELSE
               DBMS_OUTPUT.PUT_LINE('ELSIF l_Integer='||l_integer);
            END IF;
6       ELSIF false
        THEN
           DBMS_OUTPUT.PUT_LINE('ELSIF l_Integer='||l_integer);
7           IF true
            THEN
                 DBMS_OUTPUT.PUT_LINE('IF/THEN l_Integer='||l_integer);
8           ELSIF false
            THEN
               DBMS_OUTPUT.PUT_LINE('ELSIF l_Integer='||l_integer);
            ELSE
               DBMS_OUTPUT.PUT_LINE('ELSIF l_Integer='||l_integer);
            END IF;
        ELSE
           DBMS_OUTPUT.PUT_LINE('ELSIF l_Integer='||l_integer);
9           IF true
            THEN
                 DBMS_OUTPUT.PUT_LINE('IF/THEN l_Integer='||l_integer);
10          ELSIF false
            THEN
               DBMS_OUTPUT.PUT_LINE('ELSIF l_Integer='||l_integer);
            ELSE
               DBMS_OUTPUT.PUT_LINE('ELSIF l_Integer='||l_integer);
            END IF;
        END IF;
11   ELSIF false
         THEN
            DBMS_OUTPUT.PUT_LINE('ELSIF l_Integer='||l_integer);
     ELSE
        DBMS_OUTPUT.PUT_LINE('ELSIF l_Integer='||l_integer);
     END IF;
END;

//좋은 예
// 프로세스를 파악하여 기능을 분리할 수 있는지 검토한다.
// 가능하다면 소규모의 모듈로 분리한다.
     ]]></example>
    </rule>
    <!-- 2. 룰 신규 추가 (20180309) 종료 -->

    <!-- 제외 룰 -->
    <!--
    <rule ref="rulesets/java/strictexception.xml/SignatureDeclareThrowsException"/> 메소드 정의 시 throws exception 하지 않도록 권장하는 룰
    <rule ref="rulesets/java/optimizations.xml/LocalVariableCouldBeFinal"/> 파라미터 및 로컬 변수를 final로 선언하도록 권장하는 룰,
    <rule ref="rulesets/java/optimizations.xml/MethodArgumentCouldBeFinal"/> 변경 공수에 비해 개선 정도가 크지 않은 것으로 판단되어 삭제(JAVA 컴파일러에서 내부적으로 변경하여 컴파일한다고 함)
    <rule ref="rulesets/java/basic.xml/SimplifiedTernary"/> 삼항 연산자 관련 룰 , 알아보기 어려운 코드로 변경된다 판단되어 삭제 (+ java 1.6 지원)
    <rule ref="rulesets/java/unusedcode.xml/UnusedModifier"/>  interface의 경우 public 지시자를 생략하도록 권장하는 룰 , public 표시하는 것이 더 명확하다 판단되어 삭제
    <rule ref="rulesets/pom/basic.xml/InvalidDependencyTypes"/>  maven 설정 관련 룰,중요하지 않다 판단하여 제외 (+ java 1.6 지원)
    <rule ref="rulesets/pom/basic.xml/ProjectVersionAsDependencyVersion"/>
    <rule ref="rulesets/jsp/basic.xml/NoClassAttribute"/>  HTML에서 class attribute를 사용하지 않도록 권장하는 룰

    <rule ref="rulesets/java/design.xml/AbstractClassWithoutAbstractMethod" message="Abstract Class내에 Abstract Method가 존재하지 않아야 한다."/>
    <rule ref="rulesets/java/imports.xml/DuplicateImports" message="import문이 중복 선언 되었음."/>
    <rule ref="rulesets/java/design.xml/OptimizableToArrayCall" message=""/>
    <rule ref="rulesets/java/design.xml/SimplifyBooleanReturns" message=""/>
    <rule ref="rulesets/java/optimizations.xml/PrematureDeclaration" message=""/>
    <rule ref="rulesets/java/strictexception.xml/AvoidRethrowingException" message=""/>
    -->
</ruleset>
